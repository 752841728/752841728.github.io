title: 前端开发规范
author: Funny Boy
date: 2025-02-05 15:27:17
tags: ["Vue"]
categories: ["前端"]

---

# 编程规范
## 命名规范
命名分类见附录[3.1.1命名分类](#oF4X1)

### 项目命名
命名方式：短横线连接式，即全部采用小写方式，以短横线分隔

命名规范：根据实际项目名称命名

如：`my-project`

### 目录命名
命名方式：短横线连接式，即全部采用小写方式，以短横线分隔

命名规范：

1. <font style="color:rgb(31, 35, 40);">简洁。有习惯性缩写的单词 </font>_<font style="color:rgb(31, 35, 40);">必须</font>_<font style="color:rgb(31, 35, 40);">采用容易理解的缩写。如：源代码目录使用src，不使用source。</font>
    1. <font style="color:rgb(31, 35, 40);">src: 源文件目录。 </font>_<font style="color:rgb(31, 35, 40);">不允许(MUST NOT)</font>_<font style="color:rgb(31, 35, 40);"> 使用source等。</font>
2. 有复数结构时，要采用复数命名法， 缩写不用复数<font style="color:rgb(31, 35, 40);">下面是更多例子：</font>
    1. <font style="color:rgb(31, 35, 40);">images: 图片。 </font>_<font style="color:rgb(31, 35, 40);">不允许(MUST NOT)</font>_<font style="color:rgb(31, 35, 40);"> 使用image、imgs等。</font>
    2. <font style="color:rgb(31, 35, 40);">styles: 样式表。 </font>_<font style="color:rgb(31, 35, 40);">不允许(MUST NOT)</font>_<font style="color:rgb(31, 35, 40);"> 使用style等。</font>

```bash
good：scripts/styles/components/images/utils/layouts/demo-styles/demo-scripts/images/doc

bad：script/style/demo_scripts/demoStyles/imgs/docs
```

### 文件命名
命名方式：短横线连接式，即全部采用小写方式，以短横线分隔

```bash
good： render-dom.js/signup.css/index.html/company-logo.png

bad： renderDom.js/UserManagement.html

```

### <font style="color:rgb(53, 53, 53);">图片命名</font>
#### 命名顺序
图片命名建议以以下顺序命名：

**图片业务（可选） +（mod-）图片功能类别（必选）+ 图片模块名称（可选） + 图片精度（可选）**

+  图片业务：
    - pp-：拍拍
    - wx-：微信
    - sq-：手Q
    -  jd-：京东商城
    -  ...
+  图片功能类别：
    - mod-：是否公共，可选 
    - icon：模块类固化的图标
    - logo：LOGO类
    - spr：单页面各种元素合并集合
    - btn：按钮
    - bg：可平铺或者大背景
    - ...
+  图片模块名称：
    - goodslist：商品列表 
    - goodsinfo：商品信息
    - useravatar：用户头像
    - ...
+ 图片精度：
    - 普清：@1x 
    - Retina：@2x | @3x
    - ...

如下面例子：

```plain
公共模块：
wx-mod-btn-goodlist@2x.png
wx-mod-btn-goodlist.png
mod-btn-goodlist.png 

非公共模块：
wx-btn-goodlist@2x.png
wx-btn-goodlist.png
btn-goodlist.png
```



#### 交叉业务协作
业务交叉协作的时候，为了避免图片命名冲突，建议图片名加上业务和模块前辍，如拍拍侧和手Q侧的业务交叉合作时，侧栏导航icon雪碧图命名：

```plain
推荐：
pp-icon-mod-sidenav.png

不推荐：
icon-mod-sidenav.png
```



处理高清图片的时候，命名应该加上图片相应的精度说明

```bash
推荐：
jdc-logo@1x.png
jdc-logo@2x.png

不推荐：
jdc-logo.png
jdc-logo-retina.png
```

###  命名严谨性
1. 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 

说明：正确的 英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用

```bash
good：henan/luoyang/rmb 等国际通用的名称，可视同英文

bad：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3
```



2. 杜绝完全不规范的缩写，避免望文不知义：

**bad：**AbstractClass“缩写”命名成 AbsClass；condition “缩写”命名成 condi，此类随意缩写严重 降低了代码的可阅读性。

## HTML规范
### 代码规范
#### <font style="color:rgb(68, 68, 68);">DOCTYPE 声明</font>
**<font style="color:rgb(68, 68, 68);">[强制] HTML文件必须加上 DOCTYPE 声明，</font>****<font style="color:rgb(37, 41, 51);">doctype 大写，</font>****<font style="color:rgb(68, 68, 68);">并统一使用 HTML5 的文档声明</font>**

| <font style="color:rgb(77, 77, 76);"><!DOCTYPE html></font> |
| :--- |


#### <font style="color:rgb(68, 68, 68);">CHARSET</font>
<font style="color:rgb(37, 41, 51);">规定字符编码</font>

**<font style="color:rgb(68, 68, 68);">[强制] 统一使用 “UTF-8” 编码</font>**

| <font style="color:rgb(77, 77, 76);"><meta charset="UTF-8"></font> |
| :--- |


<font style="color:rgb(68, 68, 68);">请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 </font>[IETF对UTF-8的定义](http://www.ietf.org/rfc/rfc3629)<font style="color:rgb(68, 68, 68);">，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。</font>



#### 代码缩进**(prettier已配置)**
**<font style="color:rgb(68, 68, 68);">[强制] 统一使用2个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</font>**

```html
<div class="jdc">
  <a href="#"></a>
</div>
```

#### 代码大小写
**<font style="color:rgb(68, 68, 68);">[强制] HTML标签名、类名、标签属性和大部分属性值统一用小写</font>**

```html
<!-- good -->
<div class="demo"></div>

<!-- bad -->
<div class="DEMO"></div>
	
<DIV CLASS="DEMO"></DIV>
```

**<font style="color:rgb(68, 68, 68);"> HTML文本、CDATA、JavaScript、meta标签某些属性等内容可大小写混合</font>**

```html
<!-- 优先使用 IE 最新版本和 Chrome Frame -->
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>

<!-- HTML文本内容 -->
<h1>I AM WHAT I AM </h1>

<!-- JavaScript 内容 -->
<script type="text/javascript">
	var demoName = 'demoName';
	...
</script>
	
<!-- CDATA 内容 -->
<script type="text/javascript"><![CDATA[
...
]]></script>
```

#### 命名
**<font style="color:rgb(31, 35, 40);">[强制] class 必须单词全字母小写，单词间以 - 分隔(组件库中BEM(见附录</font>**[**3.1.3BEM**](#gY98d)**<font style="color:rgb(31, 35, 40);">)规则除外)</font>**

<font style="color:rgb(31, 35, 40);">示例：</font>

```css
<!-- good -->
<div class="my-form"></div>

<!-- bad -->
<div class="myForm"></div>
```

**[强制] 元素 **`**id**`** 必须保证页面唯一。**

**[建议] **`**id**`** 建议小驼峰命名法。同项目必须保持风格一致。**

**[建议] **`**id**`**、**`**class**`** 命名，在避免冲突并描述清楚的前提下尽可能短。**

示例：

<!-- good -->  
<div id="nav"></div>  
<!-- bad -->  
<div id="navigation"></div>  
  
<!-- good -->  
<p class="comment"></p>  
<!-- bad -->  
<p class="com"></p>  
  
<!-- good -->  
<span class="author"></span>  
<!-- bad -->  
<span class="red"></span>

**[强制] 禁止为了 **`**hook 脚本**`**，创建无样式信息的 **`**class**`**。**

解释：

不允许 `class` 只用于让 JavaScript 选择某些元素，`class` 应该具有明确的语义和样式。否则容易导致 CSS class 泛滥。

使用 `id`、属性选择作为 hook 是更好的方式。



**[强制] 同一页面，应避免使用相同的 **`**name**`** 与 **`**id**`**。**

解释：

IE 浏览器会混淆元素的 `id` 和 `name` 属性， `document.getElementById` 可能获得不期望的元素。所以在对元素的 `id` 与 `name` 属性的命名需要非常小心。

一个比较好的实践是，为 `id` 和 `name` 使用不同的命名法。

示例：

<input name="foo">  
<div id="foo"></div>  
<script>  
// IE6 将显示 INPUT  
// alert(document.getElementById('foo').tagName);  
</script>

#### <font style="color:rgb(68, 68, 68);">标签</font>
1. **<font style="color:rgb(68, 68, 68);">元素标签（标签分类可见附录</font>**[**3.1.2HTML元素**](#RWjyE)**<font style="color:rgb(68, 68, 68);">）的闭合应遵循以下原则</font>**
+ <font style="color:rgb(68, 68, 68);">原始文本元素、RCDATA元素以及常规元素都有一个开始标签来表示开始，一个结束标签来表示结束。</font>
+ [<font style="color:rgb(68, 68, 68);">某些元素的开始和结束标签是可以省略的</font>](http://www.w3.org/TR/html5/syntax.html#optional-tags)<font style="color:rgb(68, 68, 68);">，如果规定标签不能被省略，那么就绝对不能省略它。</font>
+ <font style="color:rgb(68, 68, 68);">空元素只有一个开始标签，且不能为空元素设置结束标签。</font>
+ <font style="color:rgb(68, 68, 68);">外来元素可以有一个开始标签和配对的结束标签，或者只有一个自闭合的开始标签，且后者情况下该元素不能有结束标签。</font>
2. **<font style="color:rgb(68, 68, 68);">为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定：</font>**

##### 标签闭合**(eslint-plugin-prettier已配置)**
+ **[强制] ****<font style="color:rgb(68, 68, 68);">所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。</font>**

解释：

对代码体积要求非常严苛的场景，可以例外。比如：第三方页面使用的投放系统。

示例：

```html
<!-- good -->
<ul>
    <li>first</li>
    <li>second</li>
</ul>

<!-- bad -->
<ul>
    <li>first
    <li>second
</ul>
```



+ **<font style="color:rgb(68, 68, 68);">[强制] 空元素标签都加 “/” 字符</font>**

示例：

```html
<!-- good -->
<input type="text" name="title" />

<!-- bad -->
<input type="text" name="title">
```



##### **标签嵌套规则。（****eslint-plugin-prettier已配置****）**
**<font style="color:rgb(68, 68, 68);">[强制] 元素嵌套规范，每个块状元素独立一行，内联元素可选</font>**

```html
<!-- good -->
<div>
    <h1></h1>
    <p></p>
</div>	
<p><span></span><span></span></p>
<!-- bad -->
<div>
    <h1></h1><p></p>
</div>	
<p> 
    <span></span>
    <span></span>
</p>
```

**<font style="color:rgb(68, 68, 68);">[强制] 段落元素与标题元素只能嵌套内联元素：比如 </font>**`**<font style="color:rgb(68, 68, 68);">div</font>**`**<font style="color:rgb(68, 68, 68);"> 不得置于 </font>**`**<font style="color:rgb(68, 68, 68);">p</font>**`**<font style="color:rgb(68, 68, 68);"> 中，</font>**`**<font style="color:rgb(68, 68, 68);">tbody</font>**`**<font style="color:rgb(68, 68, 68);"> 必须置于 </font>**`**<font style="color:rgb(68, 68, 68);">table</font>**`**<font style="color:rgb(68, 68, 68);"> 中。</font>**

```html
<!-- good -->
<h1><span></span></h1>
<p><span></span><span></span></p>

<!-- bad -->
<h1><div></div></h1>
<p><div></div><div></div></p>

```

##### **标签其他规范。**
**[建议] HTML 标签的使用应该遵循标签的语义。**

解释：

下面是常见标签语义

p - 段落

h1,h2,h3,h4,h5,h6 - 层级标题

strong,em - 强调

ins - 插入

del - 删除

abbr - 缩写

code - 代码标识

cite - 引述来源作品的标题

q - 引用

blockquote - 一段或长篇引用

ul - 无序列表

ol - 有序列表

dl,dt,dd - 定义列表

示例：

```html
<!-- good -->
<p>Esprima serves as an important <strong>building block</strong> for some JavaScript language tools.</p>

<!-- bad -->
<div>Esprima serves as an important <span class="strong">building block</span> for some JavaScript language tools.</div>
```



**[建议] 在 CSS 可以实现相同需求的情况下不得使用表格进行布局。**

解释：

在兼容性允许的情况下应尽量保持语义正确性。对网格对齐和拉伸性有严格要求的场景允许例外，如多列复杂表单。

**[建议] 标签的使用应尽量简洁，减少不必要的标签。**

示例：

```html
<!-- good -->
<img class="avatar" src="image.png"/>

<!-- bad -->
<span class="avatar">
  <img src="image.png">
</span>
```





####  属性
**[强制] 属性名必须使用小写字母。**

示例：

```html
<!-- good -->
<table cellspacing="0">...</table>

<!-- bad -->
<table cellSpacing="0">...</table>
```

**[强制] 属性值必须用双引号包围。(eslint-plugin-prettier已配置****）**

解释：

不允许使用单引号，不允许不使用引号。

示例：

```html
<!-- good -->
<script src="esl.js"></script>

<!-- bad -->
<script src='esl.js'></script>
<script src=esl.js></script>
```

**[建议] 布尔类型的属性，建议不添加属性值。**

示例：

```html
<input type="text" disabled>
<input type="checkbox" value="1" checked>
```

**[建议] 自定义属性建议以 **`**xxx-**`** 为前缀，推荐使用 **`**data-**`**。**

解释：

使用前缀有助于区分自定义属性和标准定义的属性。

示例：

```html
<ol data-ui-type="Select"></ol>
```

#### CSS 和 JavaScript 引入
**[强制] 引入 **`**CSS**`** 时必须指明 **`**rel="stylesheet"**`**。**

示例：

```html
<link rel="stylesheet" href="page.css">
```

**[建议] 引入 **`**CSS**`** 和 **`**JavaScript**`** 时无须指明 **`**type**`** 属性。**

解释：

`text/css` 和 `text/javascript` 是 `type` 的默认值。

**[建议] 展现定义放置于外部 **`**CSS**`** 中，行为定义放置于外部 **`**JavaScript**`** 中。**

解释：

结构-样式-行为的代码分离，对于提高代码的可阅读性和维护性都有好处。

**[建议] 在 **`**head**`** 中引入页面需要的所有 **`**CSS**`** 资源。**

解释：

在页面渲染的过程中，新的CSS可能导致元素的样式重新计算和绘制，页面闪烁。

**[建议] **`**JavaScript**`** 应当放在页面末尾，或采用异步加载。**

解释：

将 `script` 放在页面中间将阻断页面的渲染。出于性能方面的考虑，如非必要，请遵守此条建议。

示例：

```html
<body>
    <!-- a lot of elements -->
    <script src="init-behavior.js"></script>
</body>
```

**[建议] 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 **`**URL**`** 协议部分与页面相同，建议省略协议前缀。**

解释：

使用 `protocol-relative URL` 引入 CSS，在 `IE7/8` 下，会发两次请求。是否使用 `protocol-relative URL` 应充分考虑页面针对的环境。

示例：

```html
<script src="//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js"></script>
```

### 注释规范
#### <font style="color:rgb(68, 68, 68);">遵循标准</font>
<font style="color:rgb(68, 68, 68);">HTML注释规范写法应该遵循以下标准：</font>

+ <font style="color:rgb(68, 68, 68);">必须以4个有序字符开始：编码为 U+003C LESS-THAN SIGN 的小于号, 编码为 U+0021 EXCLAMATION MARK 的感叹号, 编码为 U+002D HYPHEN-MINUS 横线, 编码为 U+002D HYPHEN-MINUS横线 ，即 “<!--”</font>
+ <font style="color:rgb(68, 68, 68);">在此之后是注释内容，注释的内容有以下限制： </font>
    - <font style="color:rgb(68, 68, 68);">不能以单个 ">" (U+003E) 字符开始</font>
    - <font style="color:rgb(68, 68, 68);">不能以由 “-“（U+002D HYPHEN-MINUS）和 ”>” (U+003E) 组合的字符开始，即 “->”</font>
    - <font style="color:rgb(68, 68, 68);">不能包含两个连续的 U+002D HYPHEN-MINUS 字符，即 “--”</font>
    - <font style="color:rgb(68, 68, 68);">不能以一个 U+002D HYPHEN-MINUS 字符结束，即 “-”</font>
+ <font style="color:rgb(68, 68, 68);">必须以3个有序字符结束：U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN，即 “-->”</font>

<font style="color:rgb(68, 68, 68);">标准写法：</font>

```html
<!--Comment Text-->
```

<font style="color:rgb(68, 68, 68);">错误的写法：</font>

```html
<!-->The Wrong Comment Text-->

<!--->The Wrong Comment Text-->

<!--The--Wrong--Comment Text-->

<!--The Wrong Comment Text--->
```

#### 单行注释 
一般用于简单的描述，如某些状态描述、属性描述等

注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行

_推荐：_

```html
<!-- Comment Text -->
<div>...</div>
```

_不推荐：_

```html
<div>...</div><!-- Comment Text -->	
	
<div><!-- Comment Text -->
    ...
</div>
```

#### 模块注释
一般用于描述模块的名称以及模块开始与结束的位置



注释内容前后各一个空格字符，`<!-- S Comment Text -->` 表示模块开始，`<!-- E Comment Text -->` 表示模块结束，模块与模块之间相隔一行

_推荐写法：_

```html
<!-- S Comment Text A -->	
<div class="mod_a">
    ...
</div>
<!-- E Comment Text A -->
	
<!-- S Comment Text B -->	
<div class="mod_b">
    ...
</div>
<!-- E Comment Text B -->
```



_不推荐写法：_

```html
<!-- S Comment Text A -->
<div class="mod_a">
    ...
</div>
<!-- E Comment Text A -->
<!-- S Comment Text B -->	
<div class="mod_b">
    ...
</div>
<!-- E Comment Text B -->
```

#### 嵌套模块注释
当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用

```html
<!-- S Comment Text -->
<!-- E Comment Text -->
```

而改用

```html
<!-- /Comment Text -->
```

注释写在模块结尾标签底部，单独一行。

```html
<!-- S Comment Text A -->
<div class="mod_a">
		
    <div class="mod_b">
        ...
    </div>
    <!-- /mod_b -->
    	
    <div class="mod_c">
    	...
    </div>
    <!-- /mod_c -->
		
</div>
<!-- E Comment Text A -->
```

### 文件模板
HTML模版指的是团队使用的初始化HTML文件，里面会根据不同平台而采用不一样的设置，一般主要不同的设置就是 mata 标签的设置，以下是 PC 和移动端的 HTML 模版。

HTML5标准模版

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>HTML5标准模版</title>
</head>
<body>
	
</body>
</html>
```



现团队约定模板如下：

#### 移动端
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" >
<meta name="format-detection" content="telephone=no" >
<title>移动端HTML模版</title>
	
<!-- S DNS预解析 -->
<link rel="dns-prefetch" href="">
<!-- E DNS预解析 --> 

<!-- S 线上样式页面片，开发请直接取消注释引用 -->
<!-- #include virtual="" -->
<!-- E 线上样式页面片 -->

<!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --> 
<link rel="stylesheet" href="css/index.css" >
<!-- /本地调试方式 -->

<link rel="stylesheet" href="http://srcPath/index.css" >
<!-- /开发机调试方式 -->
<!-- E 本地调试 -->

</head>
<body>

</body>
</html>
```

#### PC端
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="keywords" content="your keywords">
<meta name="description" content="your description">
<meta name="author" content="author,email address">
<meta name="robots" content="index,follow">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
<meta name="renderer" content="ie-stand">
<title>PC端HTML模版</title>

<!-- S DNS预解析 --> 
<link rel="dns-prefetch" href="">
<!-- E DNS预解析 --> 

<!-- S 线上样式页面片，开发请直接取消注释引用 -->
<!-- #include virtual="" -->
<!-- E 线上样式页面片 -->

<!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --> 
<link rel="stylesheet" href="css/index.css" >
<!-- /本地调试方式 -->

<link rel="stylesheet" href="http://srcPath/index.css" >
<!-- /开发机调试方式 -->
<!-- E 本地调试 -->

</head>
<body>

</body>
</html>
```

## CSS规范
本规范的目标是使 CSS 代码风格保持一致，容易被理解和被维护。

虽然本规范是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本规范的约定。

### 代码风格
####  文件编码
**[建议] **`**CSS**`** 文件使用无 **`**BOM**`** 的 **`**UTF-8**`** 编码**。

解释：

UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。

代码格式化

#### 代码格式化 (eslint-plugin-prettier已配置)
**团队约定**

统一使用展开格式书写样式，**<font style="color:rgb(31, 35, 40);">即属性定义必须另起一行。</font>**

展开格式（Expanded）

```css
.jdc {
    display: block;
    width: 50px;
}
```

不推荐紧凑格式 (Compact)

```css
.jdc{ display: block;width: 50px;}
```

#### **<font style="color:rgb(31, 35, 40);">换行 (eslint-plugin-prettier已配置)</font>**
**<font style="color:rgb(31, 35, 40);">[强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。</font>**

```css
/* good */
.post,
.page,
.comment {
    line-height: 1.5;
}

/* bad */
.post, .page, .comment {
    line-height: 1.5;
}
```

#### 代码大小写 **<font style="color:rgb(31, 35, 40);">(eslint-plugin-prettier已配置)</font>**
样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。

```css
/* 推荐 */
.jdc {
	display:block;
}
	
/* 不推荐 */
.JDC{
	DISPLAY:BLOCK;
}
```

#### 代码缩进 **<font style="color:rgb(31, 35, 40);">(eslint-plugin-prettier已配置)</font>**
**[强制] 统一使用2个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）**

```css
.jdc {
  width: 100%;
  height: 100%;
}
```

#### 分号 （stylelint**<font style="color:rgb(31, 35, 40);">已配置)</font>**
**[强制] 每个属性声明末尾都要加分号；**

```css
.jdc {
  width: 100%;
  height: 100%;
}
```

#### 空格 **<font style="color:rgb(31, 35, 40);">(eslint-plugin-prettier已配置)</font>**
**<font style="color:rgb(31, 35, 40);">[强制] 选择器 与 { 之间必须包含空格。</font>**

```css
.selector {
}
```

**<font style="color:rgb(31, 35, 40);">[强制] >、+、~ 选择器的两边各保留一个空格。</font>**

```css
/* good */
main > nav {
    padding: 10px;
}

label + input {
    margin-left: 5px;
}

input:checked ~ button {
    background-color: #69C;
}

/* bad */
main>nav {
    padding: 10px;
}

label+input {
    margin-left: 5px;
}

input:checked~button {
    background-color: #69C;
}
```

**<font style="color:rgb(31, 35, 40);">[强制] 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。</font>**

```css
margin: 0;
```

**[强制] 逗号分隔的取值，逗号之后一个空格**

_推荐：_

```css
.jdc {
    font-family: Arial, sans-serif;
    box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;
}

```



#### 引号 **<font style="color:rgb(31, 35, 40);">(eslint-plugin-prettier已配置)</font>**
**<font style="color:rgb(31, 35, 40);">[强制] 属性选择器中的值必须用单引号包围</font>**

```css
/* good */
article[character='juliet'] {
    voice-family: "Vivien Leigh", victoria, female;
}
/* bad */
article[character="juliet"] {
    voice-family: "Vivien Leigh", victoria, female;
}
```

**[强制] css属性值需要用到引号时，统一使用单引号**

```css
/* 推荐 */
.jdc { 
	font-family: 'Hiragino Sans GB';
}

/* 不推荐 */
.jdc { 
	font-family: "Hiragino Sans GB";
}
```

### 通用
#### 选择器
**[建议]**

+ **尽量少用通用选择器 **`*****`
+ **不使用 ID 选择器**
+ **不使用无具体语义定义的标签选择器**

```css
/* 推荐 */
.jdc {}
.jdc li {}
.jdc li p{}

/* 不推荐 */
*{}
#jdc {}
.jdc div{}
```

**[强制] 如无必要，不得为 **`**id**`**、**`**class**`** 选择器添加类型选择器进行限定。**

解释：

在性能和维护性上，都有一定的影响。

示例：

```css
/* good */
#error,
.danger-message {
    font-color: #c00;
}

/* bad */
dialog#error,
p.danger-message {
    font-color: #c00;
}
```

**[建议] 选择器的嵌套层级应不大于 **`**3**`** 级，位置靠后的限定条件应尽可能精确。**

示例：

```css
/* good */
#username input {}
.comment .avatar {}

/* bad */
.page .header .login #username input {}
.comment div * {}
```

#### 属性缩写
**[建议] 在可以使用缩写的情况下，尽量使用属性缩写。**

示例：

```css
/* good */
.post {
    font: 12px/1.5 arial, sans-serif;
}

/* bad */
.post {
    font-family: arial, sans-serif;
    font-size: 12px;
    line-height: 1.5;
}
```

**[建议] 使用 **`**border**`** / **`**margin**`** / **`**padding**`** 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。**

解释：

`border` / `margin` / `padding` 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。

示例：

```css
/* centering <article class="page"> horizontally and highlight featured ones */
article {
    margin: 5px;
    border: 1px solid #999;
}

/* good */
.page {
    margin-right: auto;
    margin-left: auto;
}

.featured {
    border-color: #69c;
}

/* bad */
.page {
    margin: 5px auto; /* introducing redundancy */
}

.featured {
    border: 1px solid #69c; /* introducing redundancy */
}
```

####  属性书写顺序（已通过stylelint-config-recess-order进行自动排序）
**[建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） > Box Model（尺寸） > Typographic（文本相关） > Visual（视觉效果） 的顺序书写，以提高代码的可读性。（各css属性分类解释见附录3.1.3）**

:::info
前端工程化后可通过配置stylelint插件stylelint-config-recess-order进行按照默认顺序自动排序，智慧水务软件产品前端项目框架-`ebs_vue3_template`已内置该插件

:::

示例：

```css
.sidebar {
    /* formatting model: positioning schemes / offsets / z-indexes / display / ...  */
    position: absolute;
    top: 50px;
    left: 0;
    overflow-x: hidden;

    /* box model: sizes / margins / paddings / borders / ...  */
    width: 200px;
    padding: 5px;
    border: 1px solid #ddd;

    /* typographic: font / aligns / text styles / ... */
    font-size: 14px;
    line-height: 20px;

    /* visual: colors / shadows / gradients / ... */
    color: #333;
    background: #f5f5f5;
    -webkit-transition: color 1s;
       -moz-transition: color 1s;
            transition: color 1s;
}
```

####  清除浮动
**[建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 **`**clear**`** 或触发 **`**BFC**`** 的方式进行 **`**clearfix**`**。尽量不使用增加空标签的方式。**

解释：

触发 BFC 的方式很多，常见的有：

+ float 非 none
+ position 非 static
+ overflow 非 visible

如希望使用更小副作用的清除浮动方法，参见 [A new micro clearfix hack](http://nicolasgallagher.com/micro-clearfix-hack/) 一文。

另需注意，对已经触发 BFC 的元素不需要再进行 clearfix。

#### !important
**[建议] 尽量不使用 **`**!important**`** 声明。**

**[建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 **`**!important**`** 定义样式。**

解释：

必须注意的是，仅在设计上 `确实不允许任何其它场景覆盖样式` 时，才使用内联的 `!important` 样式。通常在第三方环境的应用中使用这种方案。下面的 `z-index` 章节是其中一个特殊场景的典型样例。

####  z-index
**[建议] 将 **`**z-index**`** 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。**

解释：

同层的多个元素，如多个由用户输入触发的 Dialog，在该层级内使用相同的 `z-index` 或递增 `z-index`。

建议每层包含100个 `z-index` 来容纳足够的元素，如果每层元素较多，可以调整这个数值。



**[建议] 在可控环境下，期望显示在最上层的元素，**`**z-index**`** 指定为 **`**999999**`**。**

解释：

可控环境分成两种，一种是自身产品线环境；还有一种是可能会被其他产品线引用，但是不会被外部第三方的产品引用。

不建议取值为 `2147483647`。以便于自身产品线被其他产品线引用时，当遇到层级覆盖冲突的情况，留出向上调整的空间。



**[建议] 在第三方环境下，期望显示在最上层的元素，通过标签内联和 **`**!important**`**，将 **`**z-index**`** 指定为 **`**2147483647**`**。**

解释：

第三方环境对于开发者来说完全不可控。在第三方环境下的元素，为了保证元素不被其页面其他样式定义覆盖，需要采用此做法。

### 值与单位（stylelint已有相关规则配置）
#### 数值
**[强制] 当数值为 0 - 1 之间的小数时，不省略整数部分的 **`**0**`**。**

示例：

```css
/* good */
panel {
    opacity: 0.8;
}

/* bad */
panel {
    opacity: .8;
}
```

#### url()(stylelint规则已有)
**[强制] **`**url()**`** 函数中的路径加引号。**

示例：

```css
body {
    background: url('bg.png');
}
```



#### 长度
**[强制] 长度为 **`**0**`** 时须省略单位。 (也只有长度单位可省)**

示例：

```css
/* good */
body {
    padding: 0 5px;
}

/* bad */
body {
    padding: 0px 5px;
}
```

#### 颜色
**[强制] RGB颜色值必须使用十六进制记号形式 **`**#rrggbb**`**。不允许使用 **`**rgb()**`**。**

解释：

带有alpha的颜色信息可以使用 `rgba()`。使用 `rgba()` 时每个逗号后必须保留一个空格。

示例：

```css
/* good */
.success {
    box-shadow: 0 0 2px rgba(0, 128, 0, .3);
    border-color: #008000;
}

/* bad */
.success {
    box-shadow: 0 0 2px rgba(0,128,0,.3);
    border-color: rgb(0, 128, 0);
}
```

**[强制] 颜色值可以缩写时，必须使用缩写形式。**

示例：

```css
/* good */
.success {
    background-color: #aca;
}

/* bad */
.success {
    background-color: #aaccaa;
}
```

**[强制] 颜色值不允许使用命名色值。**

示例：

```css
/* good */
.success {
    color: #90ee90;
}

/* bad */
.success {
    color: lightgreen;
}
```

**[建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。**

示例：

```css
/* good */
.success {
    background-color: #aca;
    color: #90ee90;
}

/* good */
.success {
    background-color: #ACA;
    color: #90EE90;
}

/* bad */
.success {
    background-color: #ACA;
    color: #90ee90;
}
```



#### 2D 位置
**[强制] 必须同时给出水平和垂直方向的位置。**

解释：

2D 位置初始值为 `0% 0%`，但在只有一个方向的值时，另一个方向的值会被解析为 center。为避免理解上的困扰，应同时给出两个方向的值。[background-position属性值的定义](http://www.w3.org/TR/CSS21/colors.html#propdef-background-position)

示例：

```css
/* good */
body {
    background-position: center top; /* 50% 0% */
}

/* bad */
body {
    background-position: top; /* 50% 0% */
}
```



### 文本编排
本公司统一使用思源黑体

### 响应式
**[强制] **`**Media Query**`** 不得单独编排，必须与相关的规则一起定义。**

示例：

```css
/* Good */
/* header styles */
@media (...) {
    /* header styles */
}

/* main styles */
@media (...) {
    /* main styles */
}

/* footer styles */
@media (...) {
    /* footer styles */
}


/* Bad */
/* header styles */
/* main styles */
/* footer styles */

@media (...) {
    /* header styles */
    /* main styles */
    /* footer styles */
}
```

**[强制] **`**Media Query**`** 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。**

示例：

```css
@media
(-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */
(min--moz-device-pixel-ratio: 2),    /* Older Firefox browsers (prior to Firefox 16) */
(min-resolution: 2dppx),             /* The standard way */
(min-resolution: 192dpi) {           /* dppx fallback */
    /* Retina-specific stuff here */
}
```

**[建议] 尽可能给出在高分辨率设备 (Retina) 下效果更佳的样式。**

### 兼容性
#### 属性前缀（autoprefixer插件处理）
**[强制] 带私有前缀的属性由长到短排列，按冒号位置对齐。**  
解释：  
标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。  
示例：

```css
.box {
    -webkit-box-sizing: border-box;
       -moz-box-sizing: border-box;
            box-sizing: border-box;
}
```

更多关于浏览器私有前辍写法：[#Vendor-specific extensions](http://www.w3.org/TR/2011/REC-CSS2-20110607/syndata.html#vendor-keywords)

#### Hack
**[建议] 需要添加 **`**hack**`** 时应尽可能考虑是否可以采用其他方式解决。**  
解释：  
如果能通过合理的 HTML 结构或使用其他的 CSS 定义达到理想的样式，则不应该使用 hack 手段解决问题。通常 hack 会导致维护成本的增加。  
**[建议] 尽量使用 **`**选择器 hack**`** 处理兼容性，而非 **`**属性 hack**`**。**  
解释：  
尽量使用符合 CSS 语法的 selector hack，可以避免一些第三方库无法识别 hack 语法的问题。  
示例：

```css
/* IE 7 */
*:first-child + html #header {
    margin-top: 3px;
    padding: 5px;
}

/* IE 6 */
* html #header {
    margin-top: 5px;
    padding: 4px;
}
```

**[建议] 尽量使用简单的 **`**属性 hack**`**。**  
示例：

```css
.box {
    _display: inline; /* fix double margin */
    float: left;
    margin-left: 20px;
}

.container {
    overflow: hidden;
    *zoom: 1; /* triggering hasLayout */
}
```

### 注释规范
+ 注释以字符 `/*` 开始，以字符 `*/` 结束
+ 注释不能嵌套

```css
/*Comment Text*/
```

#### 单行注释
**[强制] 注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行**

_推荐：_

```css
/* Comment Text */
.jdc{}

/* Comment Text */
.jdc{}
```

_不推荐：_

```css
/*Comment Text*/
.jdc{
	display: block;
}
.jdc{
	display: block;/*Comment Text*/
}
```

#### 模块注释
**[强制] 注释内容第一个字符和最后一个字符都是一个空格字符，**`**/***`** 与 模块信息描述占一行，多个横线分隔符**`**-**`**与**`***/**`**占一行，行与行之间相隔两行**

_推荐：_

```css
/* Module A
---------------------------------------------------------------- */
.mod_a {}


/* Module B
---------------------------------------------------------------- */
.mod_b {}
```

_不推荐：_

```css
/* Module A ---------------------------------------------------- */
.mod_a {}
/* Module B ---------------------------------------------------- */
.mod_b {}
```

#### 文件信息注释
**[建议] 在样式文件编码声明 **`**@charset**`** 语句下面注明页面名称、作者、创建日期等信息**



```css
@charset "UTF-8";
/**
 * @desc File Info
 * @author Author Name
 * @date 2015-10-10
 */
```

更多关于CSS注释：[#Comments](http://www.w3.org/TR/2011/REC-CSS2-20110607/syndata.html#comments)

### SASS规范（stylelint已有相关规则配置）
<font style="color:rgb(31, 35, 40);"> sass代码的基本规范和原则与css规范保持一致；</font>

#### 语法选用
SASS有两种语法格式，一种是 SCSS (Sassy CSS)，另一种是缩进格式（Indented Syntax），有时称之为 Sass。

**[强制] 考虑到 SCSS 语法对 CSS 语法友好的兼容性和扩展性，我们在使用 SASS 编写样式的时候，统一使用 SCSS 语法**

#### 编码格式
**严格遵守上面 “CSS规范” 中的 文件编码**

#### SASS注释规范
SCSS 文件内

+ **[强制] 全部遵循 CSS 注释规范**
+ **[强制] 不使用 **`**/*! */**`** 注释方式**
+ **[强制] 注释内不放 SASS 变量**

标准的注释规范如下：

```sass
@charset "UTF-8";

/**
* @desc File Info
* @author liqinuo
* @date 2015-10-10
*/

/* Module A
----------------------------------------------------------------*/
.mod_a {}

/* module A logo */
.mod_a_logo {}

/* module A nav */
.mod_a_nav {}


/* Module B
----------------------------------------------------------------*/
.mod_b {}

/* module B logo */
.mod_b_logo {}

/* module B nav */
.mod_b_nav {}
```



#### 嵌套规范
##### 选择器嵌套
```sass
/* CSS */
.jdc {}
body .jdc {}

/* SCSS */
.jdc {
    body & {}
}
```



```sass
/* CSS */
.jdc {}
.jdc_cover {}
.jdc_info {}
.jdc_info_name {}

/* SCSS */
.jdc {
    &_cover {}
    &_info {
        &_name {}
    }
}
```

##### 属性嵌套
```sass
/* CSS */
.jdc {
    background-color: red;
    background-repeat: no-repeat;
    background-image: url(/img/icon.png);
    background-position: 0 0;
}

/* SCSS */
.jdc {
    background: {
        color: red;
        repeat: no-repeat;
        image: url(/img/icon.png);
        position: 0 0;
    }
}
```

#### 变量
**[建议] 可复用属性尽量抽离为页面变量，易于统一维护**

```sass
// CSS
.jdc {
    color: red;
    border-color: red;
}

// SCSS
$color: red;
.jdc {
    color: $color;
    border-color: $color;
}
```

#### 混合(mixin)
**[建议] 根据功能定义模块，然后在需要使用的地方通过 **`**@include**`** 调用，避免编码时重复输入代码段**

```sass
// CSS
.jdc_1 {
    -webkit-border-radius: 5px;
    border-radius: 5px;
}
.jdc_2 {
    -webkit-border-radius: 10px;
    border-radius: 10px;
}

// SCSS
@mixin radius($radius:5px) {
    -webkit-border-radius: $radius;
    border-radius: $radius;
}
.jdc_1 {
    @include radius; //参数使用默认值
}
.jdc_2 {
    @include radius(10px);
}



// CSS
.jdc_1 {
    background: url(/img/icon.png) no-repeat -10px 0;
}
.jdc_2 {
    background: url(/img/icon.png) no-repeat -20px 0;
}

// SCSS
@mixin icon($x:0, $y:0) {
    background: url(/img/icon.png) no-repeat $x, $y;
}
.jdc_1 {
    @include icon(-10px, 0);
}
.jdc_2 {
    @include icon(-20px, 0);
}
```

#### 占位选择器 %
如果不调用则不会有任何多余的 css 文件，占位选择器以 `%` 标识定义，通过 `@extend` 调用

```sass
//scss
%borderbox {
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
.jdc {
    @extend %borderbox;
}
```

#### extend 继承
```sass
// CSS
.jdc_1 {
    font-size: 12px;
    color: red;
}
.jdc_2 {
    font-size: 12px;
    color: red;
    font-weight: bold;
}

// SCSS
.jdc_1 {
    font-size: 12px;
    color: red;
}
.jdc_2 {
    @extend .jdc_1;
    font-weight: bold;
}

// 或者
%font_red {
    font-size: 12px;
    color: red;
}
.jdc_1 {
    @extend %font_red;
}
.jdc_2 {
    @extend %font_red;
    font-weight: bold;
}
```

#### for 循环
```sass
// CSS
.jdc_1 {background-position: 0 -20px;}
.jdc_2 {background-position: 0 -40px;}
.jdc_3 {background-position: 0 -60px;}

// SCSS
@for $i from 1 through 3 {
    .jdc_#{$i} {
        background-position: 0 (-20px) * $i;
    }
}
```



注意：`#{}` 是连接符，变量连接使用时需要依赖

#### each 循环
```sass
// CSS
.jdc_list {
    background-image: url(/img/jdc_list.png);
}
.jdc_detail {
    background-image: url(/img/jdc_detail.png);
}

// SCSS
@each $name in list, detail {
    .jdc_#{$name} {
        background-image: url(/img/jdc_#{$name}.png);
    }
}


// CSS
.jdc_list {
    background-image: url(/img/jdc_list.png);
    background-color: red;
}
.jdc_detail {
    background-image: url(/img/jdc_detail.png);
    background-color: blue;
}

// SCSS
@each $name, $color in (list, red), (detail, blue) {
    .jdc_#{$name} {
        background-image: url(/img/jdc_#{$name}.png);
        background-color: $color;
    }
}
```

#### function 函数
```sass
@function pxToRem($px) {
    @return $px / 10px * 1rem;
}
.jdc {
    font-size: pxToRem(12px);
}
```

#### 运算规范
**[强制] 运算符之间空出一个空格**



```sass
.jdc {
    width: 100px - 50px;
    height: 30px / 5;
}
```



注意运算单位，单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意

```sass
// 正确的运算格式
.jdc {
    width: 100px - 50px;
    width: 100px + 50px;
    width: 100px * 2;
    width: 100px / 2;
}
```

### LESS规范
#### 编码
使用UTF-8编码。_不得_（MUST NOT）包含BOM信息。

#### 代码组织
代码_必须_（MUST）按如下形式按顺序组织：

1. `@import`
2. 变量声明
3. 样式声明

```less
// ✓
@import "est/all.less";

@default-text-color: #333;

.page {
    width: 960px;
    margin: 0 auto;
}
```

---

#### `@import` 语句
`@import` 语句引用的文件_必须_（MUST）写在一对引号内，`.less` 后缀_不得_（MUST NOT）省略（与引入 CSS 文件时的路径格式一致）。引号使用 `'` 和 `"` 均可，但在同一项目内_必须_（MUST）统一。

```less
// ✗
@import 'est/all';
@import "my/mixins.less";

// ✓
@import "est/all.less";
@import "my/mixins.less";
```

---

#### 空格
##### 属性、变量
选择器和 `{` 之间_必须_（MUST）保留一个空格。

属性名后的冒号（`:`）与属性值之间_必须_（MUST）保留一个空格，冒号前_不得_（MUST NOT）保留空格。

定义变量时冒号（`:`）与变量值之间_必须_（MUST）保留一个空格，冒号前_不得_（MUST NOT）保留空格。

在用逗号（`,`）分隔的列表（Less 函数参数列表、以 `,` 分隔的属性值等）中，逗号后_必须_（MUST）保留一个空格，逗号前_不得_（MUST NOT）保留空格。



```less
// ✗
.box{
    @w:50px;
    @h :30px;
    width:@w;
    height :@h;
    color: rgba(255,255,255,.3);
    transition: width 1s,height 3s;
}

// ✓
.box {
    @w: 50px;
    @h: 30px;
    width: @w;
    height: @h;
    transition: width 1s, height 3s;
}
```



##### 运算
`+` / `-` / `*` / `/` 四个运算符两侧_必须_（MUST）保留一个空格。`+` / `-` 两侧的操作数_必须_（MUST）有相同的单位，如果其中一个是变量，另一个数值_必须_（MUST）书写单位。

```less
// ✗
@a: 200px;
@b: (@a+100)*2;

// ✓
@a: 200px;
@b: (@a + 100px) * 2;
```

##### 混入（Mixin）
Mixin 和后面的空格之间_不得_（MUST NOT）包含空格。在给 mixin 传递参数时，在参数分隔符（`,` / `;`）后_必须_（MUST）保留一个空格：

```less
// ✗
.box {
    .size(30px,20px);
    .clearfix ();
}

// ✓
.box {
    .size(30px, 20px);
    .clearfix();
}
```

#### 选择器
当多个选择器共享一个声明块时，每个选择器声明_必须_（MUST）独占一行。

```less
// ✗
h1, h2, h3 {
    font-weight: 700;
}

// ✓
h1,
h2,
h3 {
    font-weight: 700;
}
```

Class 命名不得以样式信息进行描述，如 `.float-right`、`text-red` 等。

#### 省略与缩写
##### 缩写
多个属性定义可以使用缩写时， _尽量_（SHOULD）使用缩写。缩写更清晰字节数更少。常见缩写有 `margin`、`border`、`padding`、`font`、`list-style` 等。在书写时_必须_（MUST）考量缩写展开后是否有不需要覆盖的属性内容被修改，从而带来副作用。

##### 数值
对于处于 `(0, 1)` 范围内的数值，小数点前的 `0` _可以_（MAY）省略，同一项目中_必须_（MUST）保持一致。

```less
// ✗
transition-duration: 0.5s, .7s;

// ✓
transition-duration: .5s, .7s;
```

##### 0 值
当属性值为 0 时，_必须_（MUST）省略可省的单位（长度单位如 `px`、`em`，不包括时间、角度等如 `s`、`deg`）。

```less
// ✗
margin-top: 0px;

// ✓
margin-top: 0;
```

##### 颜色
颜色定义_必须_（MUST）使用 `#rrggbb` 格式定义，并在可能时_尽量_（SHOULD）缩写为 `#rgb` 形式，且避免直接使用颜色名称与 `rgb()` 表达式。

```less
// ✗
border-color: red;
color: rgb(254, 254, 254);

// ✓
border-color: #f00;
color: #fefefe;
```

##### 私有属性前缀
同一属性有不同私有前缀的，_尽量_（SHOULD）按前缀长度降序书写，标准形式_必须_（MUST）写在最后。且这一组属性以第一条的位置为准，_尽量_（SHOULD）按冒号的位置对齐。

```less
// ✓
.box {
    -webkit-transform: rotate(30deg);
       -moz-transform: rotate(30deg);
        -ms-transform: rotate(30deg);
         -o-transform: rotate(30deg);
            transform: rotate(30deg);
}
```

##### 其他
_可以_（MAY）在无其他更好解决办法时使用 CSS hack，并且_尽量_（SHOULD）使用简单的属性名 hack 如 `_zoom`、`*margin`。

_可以_（MAY）但谨慎使用 IE 滤镜。需要注意的是，IE 滤镜中图片的 URL 是以页面路径作为相对目录，而不是 CSS 文件路径。

#### 嵌套和缩进
_必须_（MUST）采用2 个空格为一次缩进， _不得_（MUST NOT）采用 TAB 作为缩进。

嵌套的声明块前_必须_（MUST）增加一次缩进，有多个声明块共享命名空间时_尽量_（SHOULD）嵌套书写，避免选择器的重复。

但是需注意的是，_尽量_（SHOULD）仅在必须区分上下文时才引入嵌套关系（在嵌套书写前先考虑如果不能嵌套，会如何书写选择器）。

```less
// ✗
.main .title {
  font-weight: 700;
}

.main .content {
  line-height: 1.5;
}

.main {
.warning {
  font-weight: 700;
}
    
  .comment-form {
    #comment:invalid {
      color: red;
    }
  }
}

// ✓
.main {
    .title {
        font-weight: 700;
    }

    .content {
        line-height: 1.5;
    }
    
    .warning {
        font-weight: 700;
    }
}

#comment:invalid {
    color: red;
}
```

#### 变量
Less 的变量值总是以同一作用域下最后一个同名变量为准，务必注意后面的设定会覆盖所有之前的设定。

变量命名_必须_（MUST）采用 `@foo-bar` 形式，_不得_（MUST NOT）使用 `@fooBar` 形式。

```less
// ✗
@sidebarWidth: 200px;
@width:800px;

// ✓
@sidebar-width: 200px;
@width: 800px;
```

#### 继承
使用继承时，如果在声明块内书写 `:extend` 语句，_必须_（MUST）写在开头：

```less
// ✗
.sub {
    color: red;
    &:extend(.mod all);
}

// ✓
.sub {
    &:extend(.mod all);
    color: red;
}
```

#### 混入（Mixin）
在定义 mixin 时，如果 mixin 名称不是一个需要使用的 className，_必须_（MUST）加上括号，否则即使不被调用也会输出到 CSS 中。

```less
// ✗
.big-text {
    font-size: 2em;
}

h3 {
    .big-text;
}

// ✓
.big-text() {
    font-size: 2em;
}

h3 {
    .big-text();
}
```

如果混入的是本身不输出内容的 mixin，_必须_（MUST）在 mixin 后添加括号（即使不传参数），以区分这是否是一个 className（修改以后是否会影响 HTML）。

```less
// ✗
.box {
    .clearfix;
    .size (20px);
}

// ✓
.box {
    .clearfix();
    .size(20px);
}
```



Mixin 的参数分隔符使用 `,` 和 `;` 均可，但在同一项目中_必须_（MUST）保持统一。

#### 命名空间
变量和 mixin 在命名时_必须_（MUST）遵循如下原则：

+ 一个项目只能引入一个无命名前缀的基础样式库（如 est）
+ 业务代码和其他被引入的样式代码中，变量和 mixin 必须有项目或库的前缀

#### 字符串
在进行字符串转义时，使用 `~""` 表达式与 `e()` 函数均可，但在同一项目中_必须_（MUST）保持一致。

字符串两侧的引号_必须_（MUST）使用 `"`

#### JS 表达式
_可以_（MAY）使用 JS 表达式（`~```）生成属性值或变量，其中包含的字符串两侧的引号_尽量_（SHOULD）使用单引号（`'`）。

#### 注释
单行注释_尽量_（SHOULD）使用 `//` 方式。

```less
// Hide everything
* {
    display: none;
}
```

## JS规范
大部分代码规范已由eslint+prettier通过规则配置实现。

### 代码规范
#### 文件编码
**[建议] JavaScript 文件使用无 `BOM` 的 `UTF-8` 编码。**

解释：

UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。

[建议] 在文件结尾处，保留一个空行。

#### 缩进 **(prettier已配置)**
**[强制] 使用 2 个空格做为一个缩进层级，不允许使用 **`**4**`** 个空格 或 **`**tab**`** 字符。**

**[强制] **`**switch**`** 下的 **`**case**`** 和 **`**default**`** 必须增加一个缩进层级。**

示例：

```javascript
// good
switch (variable) {

    case '1':
        // do...
        break;

    case '2':
        // do...
        break;

    default:
        // do...

}

// bad
switch (variable) {

case '1':
    // do...
    break;

case '2':
    // do...
    break;

default:
    // do...

}
```

#### 空格 **(prettier已配置)**
**[强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。**

示例：

```javascript
var a = !arr.length;
a++;
a = b + c;
```

**[强制] 用作代码块起始的左花括号 **`**{**`** 前必须有一个空格。**

示例：

```javascript
// good
if (condition) {
}

while (condition) {
}

function funcName() {
}

// bad
if (condition){
}

while (condition){
}

function funcName(){
}
```

**[强制] **`**if / else / for / while / function / switch / do / try / catch / finally**`** 关键字后，必须有一个空格。**

示例：

```javascript
// good
if (condition) {
}

while (condition) {
}

(function () {
})();

// bad
if(condition) {
}

while(condition) {
}

(function() {
})();
```

**[强制] 在对象创建时，属性中的 **`**:**`** 之后必须有空格，**`**:**`** 之前不允许有空格。**

示例：

```javascript
// good
var obj = {
    a: 1,
    b: 2,
    c: 3
};

// bad
var obj = {
    a : 1,
    b:2,
    c :3
};
```

**[强制] 函数声明、具名函数表达式、函数调用中，函数名和 **`**(**`** 之间不允许有空格。**

示例：

```javascript
// good
function funcName() {
}

var funcName = function funcName() {
};

funcName();

// bad
function funcName () {
}

var funcName = function funcName () {
};

funcName ();
```

**[强制] **`**,**`** 和 **`**;**`** 前不允许有空格。如果不位于行尾，**`**,**`** 和 **`**;**`** 后必须跟一个空格。**

示例：

```javascript
// good
callFunc(a, b);

// bad
callFunc(a , b) ;
```

**[强制] 在函数调用、函数声明、括号表达式、属性访问、**`**if / for / while / switch / catch**`** 等语句中，**`**()**`** 和 **`**[]**`** 内紧贴括号部分不允许有空格。**

示例：

```javascript
// good

callFunc(param1, param2, param3);

save(this.list[this.indexes[i]]);

needIncream && (variable += increament);

if (num > list.length) {
}

while (len--) {
}


// bad

callFunc( param1, param2, param3 );

save( this.list[ this.indexes[ i ] ] );

needIncreament && ( variable += increament );

if ( num > list.length ) {
}

while ( len-- ) {
}
```

**[强制] 单行声明的数组与对象，如果包含元素，**`**{}**`** 和 **`**[]**`** 内紧贴括号部分不允许包含空格。**

解释：

声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。

示例：

```javascript
// good
var arr1 = [];
var arr2 = [1, 2, 3];
var obj1 = {};
var obj2 = {name: 'obj'};
var obj3 = {
    name: 'obj',
    age: 20,
    sex: 1
};

// bad
var arr1 = [ ];
var arr2 = [ 1, 2, 3 ];
var obj1 = { };
var obj2 = { name: 'obj' };
var obj3 = {name: 'obj', age: 20, sex: 1};
```

**[强制] 行尾不得有多余的空格。**

#### 换行 **(prettier已配置)**
[**强制] 每个独立语句结束后必须换行。**

**[强制] 每行不得超过 **`**120**`** 个字符。**

解释：  
超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。

**[强制] 运算符处换行时，运算符必须在新行的行首。**  
示例：

```javascript
// good
if (user.isAuthenticated()
    && user.isInRole('admin')
    && user.hasAuthority('add-admin')
    || user.hasAuthority('delete-admin')
) {
    // Code
}

var result = number1 + number2 + number3
    + number4 + number5;


// bad
if (user.isAuthenticated() &&
    user.isInRole('admin') &&
    user.hasAuthority('add-admin') ||
    user.hasAuthority('delete-admin')) {
    // Code
}

var result = number1 + number2 + number3 +
    number4 + number5;
```



**[强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、**`**for**`** 语句等场景中，不允许在 **`**,**`** 或 **`**;**`** 前换行。**  
示例：



```javascript
// good
var obj = {
    a: 1,
    b: 2,
    c: 3
};

foo(
    aVeryVeryLongArgument,
    anotherVeryLongArgument,
    callback
);


// bad
var obj = {
    a: 1
    , b: 2
    , c: 3
};

foo(
    aVeryVeryLongArgument
    , anotherVeryLongArgument
    , callback
);
```

**[建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。**  
示例：

```javascript
// 仅为按逻辑换行的示例，不代表setStyle的最优实现
function setStyle(element, property, value) {
    if (element == null) {
        return;
    }

    element.style[property] = value;
}
```

**[建议] 在语句的行长度超过 **`**120**`** 时，根据逻辑条件合理缩进。**

示例：

```javascript
// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。
// 建议最终将右括号 ) 与左大括号 { 放在独立一行，保证与 `if` 内语句块能容易视觉辨识。
if (user.isAuthenticated()
    && user.isInRole('admin')
    && user.hasAuthority('add-admin')
    || user.hasAuthority('delete-admin')
) {
    // Code
}

// 按一定长度截断字符串，并使用 + 运算符进行连接。
// 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。
// 特别的，对于 HTML 片段的拼接，通过缩进，保持和 HTML 相同的结构。
var html = '' // 此处用一个空字符串，以便整个 HTML 片段都在新行严格对齐
    + '<article>'
    +     '<h1>Title here</h1>'
    +     '<p>This is a paragraph</p>'
    +     '<footer>Complete</footer>'
    + '</article>';

// 也可使用数组来进行拼接，相对 `+` 更容易调整缩进。
var html = [
    '<article>',
        '<h1>Title here</h1>',
        '<p>This is a paragraph</p>',
        '<footer>Complete</footer>',
    '</article>'
];
html = html.join('');

// 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。
// 所有参数必须增加一个缩进。
foo(
    aVeryVeryLongArgument,
    anotherVeryLongArgument,
    callback
);

// 也可以按逻辑对参数进行组合。
// 最经典的是 baidu.format 函数，调用时将参数分为“模板”和“数据”两块
baidu.format(
    dateFormatTemplate,
    year, month, date, hour, minute, second
);

// 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。
// 这通常出现在匿名函数或者对象初始化等作为参数时，如 `setTimeout` 函数等。
setTimeout(
    function () {
        // alert('hello');
    },
    200
);

order.data.read(
    'id=' + me.model.id,
    function (data) {
        me.attchToModel(data.result);
        callback();
    },
    300
);

// 链式调用较长时采用缩进进行调整。
$('#items')
    .find('.selected')
    .highlight()
    .end();

// 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。
var result = thisIsAVeryVeryLongCondition
    ? resultA : resultB;

var result = condition
    ? thisIsAVeryVeryLongResult
    : resultB;

// 数组和对象初始化的混用，严格按照每个对象的 `{` 和结束 `}` 在独立一行的风格书写。
var array = [
    {
        // ...
    },
    {
        // ...
    }
];
```



**[建议] 对于 **`**if...else...**`**、**`**try...catch...finally**`** 等语句，推荐使用**<font style="color:rgb(68, 68, 68);">使用 </font><font style="color:rgb(77, 77, 76);background-color:rgb(238, 238, 238);">One True Brace Style</font><font style="color:rgb(68, 68, 68);"> </font>**风格，使代码层次结构更清晰，阅读性更好。**

<font style="color:rgb(68, 68, 68);">大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下：</font>

+ **<font style="color:rgb(68, 68, 68);">One True Brace Style</font>**

```javascript
if (foo) {
  bar()
} else {
  baz()
}
```

+ **<font style="color:rgb(68, 68, 68);">Stroustrup</font>**

```javascript
if (foo) {
  bar()
}
else {
  baz()
}
```

+ **<font style="color:rgb(68, 68, 68);">Allman</font>**

```javascript
if (foo)
{
  bar()
}
else
{
  baz()
}
```

#### 分号  **(prettier已配置)**
**[强制] 省略语句结束的分号。**

**[强制] 函数定义结束不允许添加分号。**  
示例：

```javascript
// good
function funcName() {
}

// bad
function funcName() {
};

// 如果是函数表达式，分号是不允许省略的。
var funcName = function () {
};
```



**[强制] **`**IIFE**`** 必须在函数表达式外添加 **`**(**`**，非 **`**IIFE**`** 不得在函数表达式外添加 **`**(**`**。**  
解释：  
额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。  
示例：

```javascript
// good
var task = (function () {
   // Code
   return result;
})();

var func = function () {
};


// bad
var task = function () {
    // Code
    return result;
}();

var func = (function () {
});
```

#### 命名
**[强制] **`**变量**`** 使用 **`**Camel命名法**`**。**  
示例：

```javascript
let loadingModules = {};
```

**[强制] **`**常量**`** 使用 **`**全部字母大写，单词间下划线分隔**`** 的命名方式。**  
示例：

```javascript
const HTML_ENTITY = {};
```

**[强制] **`**函数**`** 使用 **`**Camel命名法**`**。**  
示例：

```javascript
function stringFormat(source) {
}
```

**[强制] 函数的 **`**参数**`** 使用 **`**Camel命名法**`**。**  
示例：

```javascript
function hear(theBells) {
}
```

**[强制] **`**类**`** 使用 **`**Pascal命名法**`**。**  
示例：

```javascript
function TextNode(options) {
}
```

**[强制] 类的 **`**方法**`** / **`**属性**`** 使用 **`**Camel命名法**`**。**  
示例：

```javascript
function TextNode(value, engine) {
    this.value = value;
    this.engine = engine;
}

TextNode.prototype.clone = function () {
    return this;
};
```

**[强制] **`**枚举变量**`** 使用 **`**Pascal命名法**`**，**`**枚举的属性**`** 使用 **`**全部字母大写，单词间下划线分隔**`** 的命名方式。**  
示例：

```javascript
var TargetState = {
    READING: 1,
    READED: 2,
    APPLIED: 3,
    READY: 4
};
```

**[强制] **`**命名空间**`** 使用 **`**Camel命名法**`**。**  
示例：

```javascript
equipments.heavyWeapons = {};
```

**[强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。**  
示例：

```javascript
function XMLParser() {
}

function insertHTML(element, html) {
}

var httpRequest = new HTTPRequest();
```

**[强制] **`**类名**`** 使用 **`**名词**`**。**  
示例：

```javascript
function Engine(options) {
}
```

**[建议] **`**函数名**`** 使用 **`**动宾短语**`**。**  
示例：

```javascript
function getStyle(element) {
}
```

**[建议] **`**boolean**`** 类型的变量使用 **`**is**`** 或 **`**has**`** 开头。**  
示例：

```javascript
var isReady = false;
var hasMoreCommands = false;
```

**[建议] **`**Promise对象**`** 用 **`**动宾短语的进行时**`** 表达。**  
示例：

```javascript
var loadingData = ajax.get('url');
loadingData.then(callback);
```

#### 注释
##### <font style="color:rgb(42, 42, 42);">单行注释</font>
双斜线后，必须跟一个空格；

缩进与下一行代码保持一致；

可位于一个代码行的末尾，与代码间隔一个空格。

示例：

```javascript
if (condition) {
    // if you made it here, then all security checks passed
    allowed();
}

var zhangsan = 'zhangsan'; // one space after code
```

##### 多行注释
最少三行, '*'后跟一个空格，具体参照如下示例：

```javascript
/*
 * one space after '*'
 */
var x = 1;
```

建议在以下情况下使用：

+ 难于理解的代码段
+ 可能存在错误的代码段
+ 浏览器特殊的HACK代码
+ 业务逻辑强相关的代码

##### 文档注释
各类标签@param, @method等请参考[usejsdoc](http://usejsdoc.org/)和[JSDoc Guide](http://yuri4ever.github.io/jsdoc/)；

建议在以下情况下使用：

+ 所有常量
+ 所有函数
+ 所有类

### 语言规范
JavaScript 是一种客户端脚本语言，这里列出了编写 JavaScript 时需要遵守的规则。数据类型可见附录[3.1.5js数据类型](#LvD8W)

#### 变量声明（eslint已配置）
+ 请记得 `const` 和 `let` 都是块级作用域，`var` 是函数级作用域

```javascript
// const and let only exist in the blocks they are defined in.
{
  let a = 1
  const b = 1
}
console.log(a) // ReferenceError
console.log(b) // ReferenceError
```

+ 对所有不可变动的常量都使用 `const`，不要使用 `var`，eslint: [prefer-const](https://eslint.org/docs/rules/prefer-const.html), [no-const-assign](https://eslint.org/docs/rules/no-const-assign.html)

> 原因：这样做可以确保你无法重新分配引用，以避免出现错误和难以理解的代码
>

```javascript
// bad
var a = 1
var b = 2

// good
const a = 1
const b = 2
```

+ 如果引用是可变动的，使用 `let` 代替 `var`，eslint: [no-var](https://eslint.org/docs/rules/no-var.html)

> 原因：`let` 是块级作用域的，而不像 `var` 属于函数级作用域
>

```javascript
// bad
var count = 1
if (count < 10) {
  count += 1
}

// good
let count = 1
if (count < 10) {
  count += 1
}
```

+ 声明变量时，请使用 `const`、`let` 关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能会和现有变量冲突，另外，也很难明确该变量的作用域是什么。这里推荐使用 `const` 来声明变量，我们需要避免全局命名空间的污染。eslint: [no-undef](http://eslint.org/docs/rules/no-undef) [prefer-const](http://eslint.org/docs/rules/prefer-const) 

```javascript
// bad
demo = new Demo()

// good
const demo = new Demo()
```

+  将所有的 `const` 和 `let` 分组 

```javascript
// bad
let a
const b
let c
const d
let e

// good
const b
const d
let a
let c
let e
```

+  变量不要进行链式赋值 

> 原因：变量链式赋值会创建隐藏的全局变量
>

```javascript
// bad
(function example() {
  // JavaScript interprets this as
  // let a = ( b = ( c = 1 ) );
  // The let keyword only applies to variable a; variables b and c become
  // global variables.
  let a = b = c = 1
}())

console.log(a) // throws ReferenceError
console.log(b) // 1
console.log(c) // 1

// good
(function example() {
  let a = 1
  let b = a
  let c = a
}())

console.log(a) // throws ReferenceError
console.log(b) // throws ReferenceError
console.log(c) // throws ReferenceError

// the same applies for `const`
```

+ 不允许出现未被使用的变量，eslint: [no-unused-vars](https://eslint.org/docs/rules/no-unused-vars)

> 原因：声明但未被使用的变量通常是不完全重构犯下的错误.这种变量在代码里浪费空间并会给读者造成困扰
>

```javascript
// bad

var some_unused_var = 42

// Write-only variables are not considered as used.
var y = 10
y = 5

// A read for a modification of itself is not considered as used.
var z = 0
z = z + 1

// Unused function arguments.
function getX (x, y) {
  return x
}

// good

function getXPlusY (x, y) {
  return x + y
}

const x = 1
const y = a + 2

// alert(getXPlusY(x, y))

// 'type' is ignored even if unused because it has a rest property sibling.
// This is a form of extracting an object that omits the specified keys.
const { type, ...coords } = data
// 'coords' is now the 'data' object without its 'type' property.
```

#### 对象（eslint已配置）
+  请使用字面量值创建对象，eslint: [no-new-object](https://eslint.org/docs/rules/no-new-object.html) 

```javascript
// bad
const a = new Object{}

// good
const a = {}
```

+  别使用保留字作为对象的键值，这样在 IE8 下不会运行 

```javascript
// bad
const a = {
  default: {},  // default 是保留字
  common: {}
}

// good
const a = {
  defaults: {},
  common: {}
}
```

+  当使用动态属性名创建对象时，请使用对象计算属性名来进行创建 

> 原因：因为这样做就可以让你在一个地方定义所有的对象属性
>

```javascript
function getKey(k) {
  return `a key named ${k}`
}

// bad
const obj = {
  id: 5,
  name: 'San Francisco'
};
obj[getKey('enabled')] = true

// good
const obj = {
  id: 5,
  name: 'San Francisco',
  [getKey('enabled')]: true
};
```

+  请使用对象方法的简写方式，eslint: [object-shorthand](https://eslint.org/docs/rules/object-shorthand.html) 

```javascript
// bad
const item = {
  value: 1,

  addValue: function (val) {
    return item.value + val
  }
}

// good
const item = {
  value: 1,

  addValue (val) {
    return item.value + val
  }
}
```

+  请使用对象属性值的简写方式，eslint: [object-shorthand](https://eslint.org/docs/rules/object-shorthand.html) 

> 原因：这样更简短且描述更清楚
>

```javascript
const job = 'FrontEnd'

// bad
const item = {
  job: job
}

// good
const item = {
  job
}
```

+ 将简写的对象属性分组后统一放到对象声明的开头

> 原因：这样更容易区分哪些属性用了简写的方式
>

```javascript
const job = 'FrontEnd'
const department = 'JDC'

// bad
const item = {
  sex: 'male',
  job,
  age: 25,
  department
}

// good
const item = {
  job,
  department,
  sex: 'male',
  age: 25
}
```

+ 只对非法标识符的属性使用引号，eslint: [quote-props](https://eslint.org/docs/rules/quote-props.html)

> 原因：因为通常来说我们认为这样主观上会更容易阅读，这样会带来代码高亮上的提升，同时也更容易被主流 JS 引擎优化
>

```javascript
// bad
const bad = {
  'foo': 3,
  'bar': 4,
  'data-blah': 5
}

// good
const good = {
  foo: 3,
  bar: 4,
  'data-blah': 5
}
```

+ 不要直接使用 `Object.prototype` 的方法, 例如 `hasOwnProperty`, `propertyIsEnumerable` 和 `isPrototypeOf` 方法，eslint: [no-prototype-builtins](https://eslint.org/docs/rules/no-prototype-builtins)

> 原因：这些方法可能会被对象自身的同名属性覆盖 - 比如 `{ hasOwnProperty: false }` 或者对象可能是一个 `null` 对象(`Object.create(null)`)
>

```javascript

// bad
console.log(object.hasOwnProperty(key))

// good
console.log(Object.prototype.hasOwnProperty.call(object, key))

// best
const has = Object.prototype.hasOwnProperty // cache the lookup once, in module scope.
console.log(has.call(object, key))
/* or */
import has from 'has' // https://www.npmjs.com/package/has
console.log(has(object, key))
```

+ 优先使用对象展开运算符 `...` 来做对象浅拷贝而不是使用 `Object.assign`，使用对象剩余操作符来获得一个包含确定的剩余属性的新对象

```javascript
// very bad
const original = { a: 1, b: 2 }
const copy = Object.assign(original, { c: 3 }) // this mutates `original` ಠ_ಠ
delete copy.a // so does this

// bad
const original = { a: 1, b: 2 }
const copy = Object.assign({}, original, { c: 3 }) // copy => { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 }
const copy = { ...original, c: 3 } // copy => { a: 1, b: 2, c: 3 }

const { a, ...noA } = copy // noA => { b: 2, c: 3 }
```

#### 数组
+  请使用字面量值创建数组，eslint: [no-array-constructor](https://eslint.org/docs/rules/no-array-constructor.html) 

```javascript
// bad
const items = new Array()

// good
const items = []
```

+  向数组中添加元素时，请使用 `push` 方法 

```javascript
const items = []

// bad
items[items.length] = 'test'

// good
items.push('test')
```



+  使用展开运算符 `...` 复制数组 

```javascript
// bad
const items = []
const itemsCopy = []
const len = items.length
let i

// bad
for (i = 0; i < len; i++) {
  itemsCopy[i] = items[i]
}

// good
itemsCopy = [...items]
```

+  把一个可迭代的对象转换为数组时，使用展开运算符 `...` 而不是 `Array.from` 

```javascript
const foo = document.querySelectorAll('.foo')

// good
const nodes = Array.from(foo)

// best
const nodes = [...foo]
```

+ 使用 `Array.from` 来将一个类数组对象转换为数组

```javascript
const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 }

// bad
const arr = Array.prototype.slice.call(arrLike)

// good
const arr = Array.from(arrLike)
```

+ 遍历迭代器进行映射时使用 `Array.from` 代替扩展运算符 `...`, 因为这可以避免创建中间数组

```javascript
// bad
const baz = [...foo].map(bar)

// good
const baz = Array.from(foo, bar)
```

+  使用数组的 `map` 等方法时，请使用 `return` 声明，如果是单一声明语句的情况，可省略 `return` 

```javascript
// good
[1, 2, 3].map(x => {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map(x => x + 1)

// bad
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) => {
  const flatten = memo.concat(item)
  flat[index] = flatten
})

// good
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) => {
  const flatten = memo.concat(item)
  flat[index] = flatten
  return flatten
})

// bad
inbox.filter((msg) => {
  const { subject, author } = msg
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee'
  } else {
    return false
  }
})

// good
inbox.filter((msg) => {
  const { subject, author } = msg
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee'
  }

  return false
})
```

+  如果一个数组有多行则要在数组的开括号后和闭括号前使用新行 

```javascript
// bad
const arr = [
  [0, 1], [2, 3], [4, 5]
]

const objectInArray = [{
  id: 1
}, {
  id: 2
}]

const numberInArray = [
  1, 2
]

// good
const arr = [[0, 1], [2, 3], [4, 5]]

const objectInArray = [
  {
    id: 1
  },
  {
    id: 2
  }
]

const numberInArray = [
  1,
  2
]
```

#### 解构赋值
+ 当需要使用对象的多个属性时，请使用解构赋值，eslint: [prefer-destructuring](https://eslint.org/docs/rules/prefer-destructuring)

> 愿意：解构可以避免创建属性的临时引用
>

```javascript
// bad
function getFullName (user) {
  const firstName = user.firstName
  const lastName = user.lastName

  return `${firstName} ${lastName}`
}

// good
function getFullName (user) {
  const { firstName, lastName } = user

  return `${firstName} ${lastName}`
}

// better
function getFullName ({ firstName, lastName }) {
  return `${firstName} ${lastName}`
}
```

+  当需要使用数组的多个值时，请同样使用解构赋值，eslint: [prefer-destructuring](https://eslint.org/docs/rules/prefer-destructuring) 

```javascript
const arr = [1, 2, 3, 4]

// bad
const first = arr[0]
const second = arr[1]

// good
const [first, second] = arr
```

+  函数需要回传多个值时，请使用对象的解构，而不是数组的解构 

> 原因：可以非破坏性地随时增加或者改变属性顺序
>

```javascript
// bad
function doSomething () {
  return [top, right, bottom, left]
}

// 如果是数组解构，那么在调用时就需要考虑数据的顺序
const [top, xx, xxx, left] = doSomething()

// good
function doSomething () {
  return { top, right, bottom, left }
}

// 此时不需要考虑数据的顺序
const { top, left } = doSomething()
```

#### 字符串（eslint已配置）
+  字符串统一使用单引号的形式 `''`，eslint: [quotes](https://eslint.org/docs/rules/quotes.html) 

```javascript
// bad
const department = "JDC"

// good
const department = 'JDC'
```

+  字符串太长的时候，请不要使用字符串连接符换行 `\`，而是使用 `+` 

```javascript
const str = '凹凸实验室 凹凸实验室 凹凸实验室' +
  '凹凸实验室 凹凸实验室 凹凸实验室' +
  '凹凸实验室 凹凸实验室'
```

+  程序化生成字符串时，请使用模板字符串，eslint: [prefer-template](http://eslint.org/docs/rules/prefer-template.html) [template-curly-spacing](https://eslint.org/docs/rules/template-curly-spacing) 

```javascript
const test = 'test'

// bad
const str = ['a', 'b', test].join()

// bad
const str = 'a' + 'b' + test

// good
const str = `ab${test}`
```

+  不要对字符串使用eval()，会导致太多漏洞， eslint: [no-eval](https://eslint.org/docs/rules/no-eval) 
+  不要在字符串中使用不必要的转义字符， eslint: [no-useless-escape](https://eslint.org/docs/rules/no-useless-escape) 

```javascript
// bad
const foo = '\'this\' \i\s \"quoted\"'

// good
const foo = '\'this\' is "quoted"'
const foo = `my name is '${name}'`
```

#### 函数（eslint已配置）
+ 不要使用Function构造函数创建函数， eslint: [no-new-func](https://eslint.org/docs/rules/no-new-func)

> 原因：此方式创建函数和对字符串使用 `eval()` 一样会产生漏洞
>

```javascript
// bad
const add = new Function('a', 'b', 'return a + b')

// still bad
const subtract = Function('a', 'b', 'return a - b')
```

+ 在函数签名中使用空格，eslint: [space-before-function-paren](https://eslint.org/docs/rules/space-before-function-paren) [space-before-blocks](https://eslint.org/docs/rules/space-before-blocks)

```javascript
const f = function(){}
const g = function (){}
const h = function() {}

// good
const x = function b () {}
const y = function a () {}
```

+ 使用具名函数表达式而非函数声明，eslint: [func-style](http://eslint.org/docs/rules/func-style)

> 原因：这样做会导致函数声明被提升，这意味着很容易在文件中定义此函数之前引用它，不利于可读性和可维护性。如果你发现函数定义既庞大又复杂以至于不能理解文件的其他部分，或许你应该将它拆分成模块！别忘记要显式命名表达式，而不用管名字是否是从包含的变量（通常出现在现代浏览器中或者使用 Babel 编译器的时候）中推断的。这样会消除错误调用堆栈中的任何假设。 (讨论)
>

```javascript
// bad
function foo () {
  // ...
}

// bad
const foo = function () {
  // ...
}

// good
// lexical name distinguished from the variable-referenced invocation(s)
const short = function longUniqueMoreDescriptiveLexicalFoo () {
  // ...
}
```

+ 用圆括号包裹自执行匿名函数，eslint：[wrap-iife](http://eslint.org/docs/rules/wrap-iife.html)

> 原因：一个立即执行匿名函数表达式是一个单一的单元，将其及其调用括号包装在括号中，能够清楚地表达这一点。注意，在到处都是模块的世界中几乎不需要 IIFE。
>

```javascript
// immediately-invoked function expression (IIFE)
(function () {
  console.log('Welcome to the Internet. Please follow me.')
}())
```

+  不要在非函数代码块（`if` , `while` 等）中声明函数，eslint：[no-loop-func](http://eslint.org/docs/rules/no-loop-func.html) 

```javascript
// bad
if (isUse) {
  function test () {
    // do something
  }
}

// good
let test
if (isUse) {
  test = () => {
    // do something
  }
}
```

+  不要将参数命名为 `arguments`，会导致该参数的优先级高于每个函数作用域内原先存在的 `arguments` 对象 

```javascript
// bad
function foo (name, options, arguments) {
  // ...
}

// good
function foo (name, options, args) {
  // ...
}
```

+  不要使用 `arguments`，使用 剩余运算符 `...` 

> `arguments` 只是一个类数组，而 `...` 是一个真正的数组
>

```javascript
// bad
function test () {
  const args = Array.prototype.slice.call(arguments)
  return args.join('')
}

// good
function test (...args) {
  return args.join('')
}
```

+  使用参数默认值语法而不是修改函数参数 

```javascript
// really bad
function handleThings (opts) {
  // No! We shouldn't mutate function arguments.
  // Double bad: if opts is falsy it'll be set to an object which may
  // be what you want but it can introduce subtle bugs.
  opts = opts || {}
  // ...
}

// still bad
function handleThings (opts) {
  if (opts === void 0) {
    opts = {}
  }
  // ...
}

// good
function handleThings (opts = { }) {
  // ...
}
```

+ 避免参数默认值的副作用

```javascript
let b = 1
// bad
function count (a = b++) {
  console.log(a)
}
count()  // 1
count()  // 2
count(3) // 3
count()  // 3
```

+ 将参数默认值放在最后

```javascript
// bad
function handleThings (opts = {}, name) {
  // ...
}

// good
function handleThings (name, opts = {}) {
  // ...
}
```

+ 不要更改参数，eslint: [no-param-reassign](https://eslint.org/docs/rules/no-param-reassign.html)

> 原因：操作作为参数传入的对象可能在原始调用中造成意想不到的变量副作用
>

```javascript
// bad
function f1 (obj) {
  obj.key = 1
}

// good
function f2 (obj) {
  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1
}
```

+ 不要给参数重新赋值，eslint: [no-param-reassign](https://eslint.org/docs/rules/no-param-reassign.html)

> 原因：参数重新赋值可能会导致无法预期的行为，尤其是当操作 `arguments` 对象时，也可能导致优化问题，尤其是在 V8 引擎中
>

```javascript
// bad
function f1 (a) {
  a = 1
}

function f2 (a) {
  if (!a) { a = 1 }
}

// good
function f3 (a) {
  const b = a || 1
}

function f4 (a = 1) {
}
```

+ 调用可变参数函数时建议使用展开运算符 `....`， eslint: [prefer-spread](http://eslint.org/docs/rules/prefer-spread)

> 原因：显然你无需使用上下文，很难结合 `new` 和 `apply`
>

```javascript
// bad
const x = [1, 2, 3, 4, 5]
console.log.apply(console, x)

// good
const x = [1, 2, 3, 4, 5]
console.log(...x)

// bad
new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]))

// good
new Date(...[2016, 8, 5])
```

#### 箭头函数 （eslint已配置）
+ 当你必须使用函数表达式（传递匿名函数）时，使用箭头函数标记. eslint: [prefer-arrow-callback](http://eslint.org/docs/rules/prefer-arrow-callback.html), [arrow-spacing](https://eslint.org/docs/rules/arrow-spacing.html)

> 原因：它将创建在 `this` 上下文中执行的函数版本，通常是您想要的，并且语法更简洁
>

> 如果您有一个相当复杂的函数，则可以将该逻辑移到其自己的命名函数表达式中
>

```javascript
// bad
[1, 2, 3].map(function (x) {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map((x) => {
  const y = x + 1
  return x * y
})
```

+ 如果函数体只包含一条没有副作用的返回表达式的语句，可以省略花括号并使用隐式的 `return`， 否则保留花括号并使用 `return` 语句，eslint: [arrow-parens](https://eslint.org/docs/rules/arrow-parens.html), [arrow-body-style](https://eslint.org/docs/rules/arrow-body-style.html)

```javascript
// bad
[1, 2, 3].map(number => {
  const nextNumber = number + 1
  `A string containing the ${nextNumber}.`
})

// good
[1, 2, 3].map(number => `A string containing the ${number}.`)

// good
[1, 2, 3].map((number) => {
  const nextNumber = number + 1
  return `A string containing the ${nextNumber}.`
})

// good
[1, 2, 3].map((number, index) => ({
  index: number
}))

// No implicit return with side effects
function foo(callback) {
  const val = callback()
  if (val === true) {
    // Do something if callback returns true
  }
}

let bool = false

// bad
foo(() => bool = true)

// good
foo(() => {
  bool = true
})
```

+ 一旦表达式跨多行，使用圆括号包裹以便更好阅读

```javascript
// bad
['get', 'post', 'put'].map(httpMethod => Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod
  )
)

// good
['get', 'post', 'put'].map(httpMethod => (
  Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod
  )
))
```

+ 函数如果只接收一个参数并且没使用用花括号，则省略圆括号，否则为了清晰明确则使用圆括号包裹参数，注意：总是使用圆括号也是可以接受的，eslint 中的 ["always" 选项](https://eslint.org/docs/rules/arrow-parens#always)，eslint: [arrow-parens](http://eslint.org/docs/rules/arrow-parens.html)

```javascript
// bad
[1, 2, 3].map((x) => x * x)

// good
[1, 2, 3].map(x => x * x)

// good
[1, 2, 3].map(number => (
  `A long string with the ${number}. It’s so long that we’ve broken it ` +
  'over multiple lines!'
))

// bad
[1, 2, 3].map(x => {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map((x) => {
  const y = x + 1
  return x * y
})
```

#### 类&构造函数
+  使用 `class`，避免直接操作 `prototype` 

```javascript
// bad
function Queue (contents = []) {
  this._queue = [..contents]
}
Queue.prototype.pop = function () {
  const value = this._queue[0]
  this._queue.splice(0, 1)
  return value
}

// good
class Queue {
  constructor (contents = []) {
    this._queue = [...contents]
  }

  pop () {
    const value = this._queue[0]
    this._queue.splice(0, 1)
    return value
  }
}
```

+  使用 `extends` 来实现继承 

> 原因：这是一个不会破坏 `instanceof` 的内建实现原型式继承的方式
>

```javascript
// bad
const inherits = require('inherits')
function PeekableQueue(contents) {
  Queue.apply(this, contents)
}
inherits(PeekableQueue, Queue)
PeekableQueue.prototype.peek = function () {
  return this.queue[0]
}

// good
class PeekableQueue extends Queue {
  peek () {
    return this.queue[0]
  }
}
```

+ 如果未声明构造函数，则类会有一个默认的构造函数，没必要用空的构造函数或者将其委托给父类，eslint: [no-useless-constructor](http://eslint.org/docs/rules/no-useless-constructor)

```javascript
// bad
class Jedi {
  constructor () {}

  getName() {
    return this.name
  }
}

// bad
class Rey extends Jedi {
  constructor (...args) {
    super(...args)
  }
}

// good
class Rey extends Jedi {
  constructor (...args) {
    super(...args)
    this.name = 'Rey'
  }
}
```

+ 避免类成员重复，eslint: [no-dupe-class-members](https://eslint.org/docs/rules/no-dupe-class-members)

> 原因：重复的类成员声明会默认使用最后声明的，通常会导致 bug
>

```javascript
// bad
class Foo {
  bar () { return 1 }
  bar () { return 2 }
}

// good
class Foo {
  bar () { return 1 }
}

// good
class Foo {
  bar () { return 2 }
}
```

#### 模块（eslint已配置）
+ 使用标准的 ES6 模块语法 `import` 和 `export`

> 原因：模块是未来，让我们现在开始使用未来的特性
>

```javascript
// bad
const util = require('./util')
module.exports = util

// good
import Util from './util'
export default Util

// better
import { Util } from './util'
export default Util
```

+  同个文件每个模块只允许 `import` 一次，有多个 `import` 请书写在一起，eslint: [no-duplicate-imports](https://eslint.org/docs/rules/no-duplicate-imports) 

> 原因：这样可以让代码更易于维护
>



```javascript
// bad
import foo from 'foo'
// … some other imports … //
import { named1, named2 } from 'foo'

// good
import foo, { named1, named2 } from 'foo'

// good
import foo, {
  named1,
  named2
} from 'foo'
```

+ 将所有 `import` 语句放在文件最前方，eslint: [import/imports-first](https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/first.md)

```javascript
// bad
import foo from 'foo'
foo.init()

import bar from 'bar'

// good
import foo from 'foo'
import bar from 'bar'

foo.init()
```

+ 多行导入应该像多行数组和对象文字一样缩进

```javascript
// bad
import { longNameA, longNameB, longNameC, longNameD, longNameE } from 'path'

// good
import {
  longNameA,
  longNameB,
  longNameC,
  longNameD,
  longNameE
} from 'path'
```

+ 在模块 `import` 声明中禁止使用 `Webpack` 的 `loader` 语法，eslint: [import/no-webpack-loader-syntax](https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-webpack-loader-syntax.md)

```javascript
// bad
import fooSass from 'css!sass!foo.scss'
import barCss from 'style!css!bar.css'

// good
import fooSass from 'foo.scss'
import barCss from 'bar.css'
```

#### 迭代器（eslint已配置）
+ 不要使用 `iterators`，建议使用 JS 更高优先级的函数代替 for-in 或 for-of 循环，除非迫不得已，eslint: [no-iterator](https://eslint.org/docs/rules/no-iterator.html) [no-restricted-syntax](https://eslint.org/docs/rules/no-restricted-syntax)

```javascript
const numbers = [1, 2, 3, 4, 5]

// bad
let sum = 0
for (let num of numbers) {
  sum += num
}

// good
let sum = 0
numbers.forEach(num => sum += num)

// better
const sum = numbers.reduce((total, num) => total + num, 0)
```

#### 生成器
+ 现阶段请不要使用生成器 `generator`

> 原因：因为不能很好地翻译成 ES5 代码
>

#### 对象属性（eslint已配置）
+  使用 `.` 来访问对象属性 

```javascript
const joke = {
  name: 'haha',
  age: 28
}

// bad
const name = joke['name']

// good
const name = joke.name
```

+  当访问的属性是变量时使用 `[]` 

```javascript
const luke = {
  jedi: true,
  age: 28,
}

function getProp (prop) {
  return luke[prop]
}

const isJedi = getProp('jedi')
```

#### Hoisting
+  `var` 存在变量提升的情况，即 `var` 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 `const` 和 `let` 并不存在这种情况，他们被赋予了 [Temporal Dead Zones, TDZ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)， 了解 [typeof 不再安全](http://es-discourse.com/t/why-typeof-is-no-longer-safe/15)很重要 

```javascript
function example () {
  console.log(notDefined)   // => throws a ReferenceError
}

function example () {
  console.log(declareButNotAssigned)  // => undefined
  var declaredButNotAssigned = true
}

function example () {
  let declaredButNotAssigned
  console.log(declaredButNotAssigned)   // => undefined
  declaredButNotAssigned = true
}

function example () {
  console.log(declaredButNotAssigned)   // => throws a ReferenceError
  console.log(typeof declaredButNotAssigned)  // => throws a ReferenceError
  const declaredButNotAssigned = true
}
```

+  匿名函数的变量名会提升，但函数内容不会 

```javascript
function example () {
  console.log(anonymous)  // => undefined

  anonymous()

  var anonymous = function () {
    console.log('test')
  }
}
```

+  命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会 

```javascript
function example() {
  console.log(named)  // => undefined

  named()   // => TypeError named is not a function

  superPower()  // => ReferenceError superPower is not defined

  var named = function superPower () {
    console.log('Flying')
  }
}

function example() {
  console.log(named)  // => undefined

  named()   // => TypeError named is not a function

  var named = function named () {
    console.log('named')
  }
}
```

#### 比较运算符&相等（eslint已配置）
+  使用 `===` 和 `!==` 而非 `==` 和 `!=`，eslint: [eqeqeq](https://eslint.org/docs/rules/eqeqeq.html) 
+  条件声明例如 `if` 会用 `ToBoolean` 这个抽象方法将表达式转成布尔值并遵循如下规则 
    - `Objects` 等于 `true`
    - `Undefined` 等于 `false`
    - `Null` 等于 `false`
    - `Booleans` 等于 `布尔值`
    - `Numbers` 在 `+0`, `-0`, 或者 `NaN` 的情况下等于 `false`, 其他情况是 `true`
    - `Strings` 为 `''` 时等于 `false`, 否则是 `true`

```javascript
if ([0] && []) {
  // true
  // 数组(即使是空数组)也是对象，对象等于true
}
```



#### 标准特性
为了代码的可移植性和兼容性，我们应该最大化的使用标准方法，例如优先使用 `string.charAt(3)` 而不是 `string[3]`

#### eval()（eslint已配置）
由于 `eval` 方法比较 `evil`，所以我们约定禁止使用该方法

#### with() {}（eslint已配置）
由于 `with` 方法会产生神奇的作用域，所以我们也是禁止使用该方法的

#### 修改内置对象的原型（eslint已配置）
不要修改内置对象，如 `Object` 和 `Array`

### 注释规范
####  单行注释
**[强制] 必须独占一行。**`**//**`** 后跟一个空格，缩进与下一行被注释说明的代码一致。**

####  多行注释
**[建议] 避免使用 **`**/*...*/**`** 这样的多行注释。有多行注释内容时，使用多个单行注释。**

#### 文档化注释
**[强制] 为了便于代码阅读和自文档化，以下内容必须包含以 **`**/**...*/**`** 形式的块注释中。**

解释：

1. 文件
2. namespace
3. 类
4. 函数或方法
5. 类属性
6. 事件
7. 全局变量
8. 常量
9. AMD 模块

**[强制] 文档注释前必须空一行。**

**[建议] 自文档化的文档说明 what，而不是 how。**

#### 类型定义
**[强制] 类型定义都是以 **`**{**`** 开始, 以 **`**}**`** 结束。**

解释：

常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。

类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。

[强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。

| 类型定义 | 语法示例 | 解释 |
| --- | --- | --- |
| String | {string} | -- |
| Number | {number} | -- |
| Boolean | {boolean} | -- |
| Object | {Object} | -- |
| Function | {Function} | -- |
| RegExp | {RegExp} | -- |
| Array | {Array} | -- |
| Date | {Date} | -- |
| 单一类型集合 | {Array.<string>} | string 类型的数组 |
| 多类型 | {(number｜boolean)} | 可能是 number 类型, 也可能是 boolean 类型 |
| 允许为null | {?number} | 可能是 number, 也可能是 null |
| 不允许为null | {!Object} | Object 类型, 但不是 null |
| Function类型 | {function(number, boolean)} | 函数, 形参类型 |
| Function带返回值 | {function(number, boolean):string} | 函数, 形参, 返回值类型 |
| Promise | Promise.<resolveType, rejectType> | Promise，成功返回的数据类型，失败返回的错误类型 |
| 参数可选 | [@param ](/param )<br/> {string=} name  | 可选参数, =为类型后缀 |
| 可变参数 | [@param ](/param )<br/> {...number} args  | 变长参数,  ...为类型前缀 |
| 任意类型 | {*} | 任意类型 |
| 可选任意类型 | [@param ](/param )<br/> {*=} name  | 可选参数，类型不限 |
| 可变任意类型 | [@param ](/param )<br/> {...*} args  | 变长参数，类型不限 |


####  文件注释
**[强制] 文件顶部必须包含文件注释，用 **`**@file**`** 标识文件说明。**

示例：

```javascript
/**
 * @file Describe the file
 */
```

**[建议] 文件注释中可以用 **`**@author**`** 标识开发者信息。**

解释：

开发者信息能够体现开发人员对文件的贡献，并且能够让遇到问题或希望了解相关信息的人找到维护人。通常情况文件在被创建时标识的是创建者。随着项目的进展，越来越多的人加入，参与这个文件的开发，新的作者应该被加入 `@author` 标识。



`@author` 标识具有多人时，原则是按照 `责任` 进行排序。通常的说就是如果有问题，就是找第一个人应该比找第二个人有效。比如文件的创建者由于各种原因，模块移交给了其他人或其他团队，后来因为新增需求，其他人在新增代码时，添加 `@author` 标识应该把自己的名字添加在创建人的前面。



`@author` 中的名字不允许被删除。任何劳动成果都应该被尊重。



业务项目中，一个文件可能被多人频繁修改，并且每个人的维护时间都可能不会很长，不建议为文件增加 `@author` 标识。通过版本控制系统追踪变更，按业务逻辑单元确定模块的维护责任人，通过文档与wiki跟踪和查询，是更好的责任管理方式。



对于业务逻辑无关的技术型基础项目，特别是开源的公共项目，应使用 `@author` 标识。

示例：

```javascript
/**
 * @file Describe the file
 * @author author-name(mail-name@domain.com)
 *         author-name2(mail-name2@domain.com)
 */
```



####  命名空间注释
**[建议] 命名空间使用 **`**@namespace**`** 标识。**

示例：

```javascript
/**
 * @namespace
 */
var util = {};
```

####  类注释
**[建议] 使用 **`**@class**`** 标记类或构造函数。**

解释：

对于使用对象 `constructor` 属性来定义的构造函数，可以使用 `@constructor` 来标记。

示例：

```javascript
/**
 * 描述
 *
 * @class
 */
function Developer() {
    // constructor body
}
```

**[建议] 使用 **`**@extends**`** 标记类的继承信息。**

示例：

```javascript
/**
 * 描述
 *
 * @class
 * @extends Developer
 */
function Fronteer() {
    Developer.call(this);
    // constructor body
}
util.inherits(Fronteer, Developer);
```

**[强制] 使用包装方式扩展类成员时， 必须通过 **`**@lends**`** 进行重新指向。**

解释：

没有 `@lends` 标记将无法为该类生成包含扩展类成员的文档。

示例：

```javascript
/**
 * 类描述
 *
 * @class
 * @extends Developer
 */
function Fronteer() {
    Developer.call(this);
    // constructor body
}

util.extend(
    Fronteer.prototype,
    /** @lends Fronteer.prototype */{
        getLevel: function () {
            // TODO
        }
    }
);
```

**[强制] 类的属性或方法等成员信息不是 **`**public**`** 的，应使用 **`**@protected**`** 或 **`**@private**`** 标识可访问性。**

解释：

生成的文档中将有可访问性的标记，避免用户直接使用非 `public` 的属性或方法。

示例：

```javascript
/**
 * 类描述
 *
 * @class
 * @extends Developer
 */
var Fronteer = function () {
    Developer.call(this);

    /**
     * 属性描述
     *
     * @type {string}
     * @private
     */
    this.level = 'T12';

    // constructor body
};
util.inherits(Fronteer, Developer);

/**
 * 方法描述
 *
 * @private
 * @return {string} 返回值描述
 */
Fronteer.prototype.getLevel = function () {
};
```

####  函数/方法注释
**[强制] 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。**

解释：

当 `return` 关键字仅作退出函数/方法使用时，无须对返回值作注释标识。

**[强制] 参数和返回值注释必须包含类型信息，且不允许省略参数的说明。**

**[建议] 当函数是内部函数，外部不可访问时，可以使用 **`**@inner**`** 标识。**

示例：

```javascript
/**
 * 函数描述
 *
 * @param {string} p1 参数1的说明
 * @param {string} p2 参数2的说明，比较长
 *     那就换行了.
 * @param {number=} p3 参数3的说明（可选）
 * @return {Object} 返回值描述
 */
function foo(p1, p2, p3) {
    var p3 = p3 || 10;
    return {
        p1: p1,
        p2: p2,
        p3: p3
    };
}
```

**[强制] 对 Object 中各项的描述， 必须使用 **`**@param**`** 标识。**

示例：

```javascript
/**
 * 函数描述
 *
 * @param {Object} option 参数描述
 * @param {string} option.url option项描述
 * @param {string=} option.method option项描述，可选参数
 */
function foo(option) {
    // TODO
}
```

**[建议] 重写父类方法时， 应当添加 **`**@override**`** 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 **`**@param**`**、**`**@return**`**，仅用 **`**@override**`** 标识，否则仍应作完整注释。**

解释：

简而言之，当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。

#### 事件注释
**[强制] 必须使用 **`**@event**`** 标识事件，事件参数的标识与方法描述的参数标识相同。**

示例：

```javascript
/**
 * 值变更时触发
 *
 * @event Select#change
 * @param {Object} e e描述
 * @param {string} e.before before描述
 * @param {string} e.after after描述
 */
this.fire(
    'change',
    {
        before: 'foo',
        after: 'bar'
    }
);
```

**[强制] 在会广播事件的函数前使用 **`**@fires**`** 标识广播的事件，在广播事件代码前使用 **`**@event**`** 标识事件。**

**[建议] 对于事件对象的注释，使用 **`**@param**`** 标识，生成文档时可读性更好。**

示例：

```javascript
/**
 * 点击处理
 *
 * @fires Select#change
 * @private
 */
Select.prototype.clickHandler = function () {

    /**
     * 值变更时触发
     *
     * @event Select#change
     * @param {Object} e e描述
     * @param {string} e.before before描述
     * @param {string} e.after after描述
     */
    this.fire(
        'change',
        {
            before: 'foo',
            after: 'bar'
        }
    );
};
```

#### 常量注释
**[强制] 常量必须使用 **`**@const**`** 标记，并包含说明和类型信息。**

示例：

```javascript
/**
 * 常量说明
 *
 * @const
 * @type {string}
 */
var REQUEST_URL = 'myurl.do';
```

#### 复杂类型注释
**[建议] 对于类型未定义的复杂结构的注释，可以使用 **`**@typedef**`** 标识来定义。**

示例：

```javascript
// `namespaceA~` 可以换成其它 namepaths 前缀，目的是为了生成文档中能显示 `@typedef` 定义的类型和链接。
/**
 * 服务器
 *
 * @typedef {Object} namespaceA~Server
 * @property {string} host 主机
 * @property {number} port 端口
 */

/**
 * 服务器列表
 *
 * @type {Array.<namespaceA~Server>}
 */
var servers = [
    {
        host: '1.2.3.4',
        port: 8080
    },
    {
        host: '1.2.3.5',
        port: 8081
    }
];
```

####  AMD 模块注释
**[强制] AMD 模块使用 **`**@module**`** 或 **`**@exports**`** 标识。**

解释：

[@exports ](/exports ) 与 [@module ](/module ) 都可以用来标识模块，区别在于 [@module ](/module ) 可以省略模块名称。而只使用 [@exports ](/exports ) 时在 namepaths 中可以省略 module: 前缀。 

示例：

```javascript
define(
    function (require) {

        /**
         * foo description
         *
         * @exports Foo
         */
        var foo = {
            // TODO
        };

        /**
         * baz description
         *
         * @return {boolean} return description
         */
        foo.baz = function () {
            // TODO
        };

        return foo;

    }
);
```

也可以在 exports 变量前使用 [@module ](/module ) 标识： 

```javascript
define(
    function (require) {

        /**
         * module description.
         *
         * @module foo
         */
        var exports = {};


        /**
         * bar description
         *
         */
        exports.bar = function () {
            // TODO
        };

        return exports;
    }
);
```

如果直接使用 factory 的 exports 参数，还可以：

```javascript
/**
 * module description.
 *
 * @module
 */
define(
    function (require, exports) {

        /**
         * bar description
         *
         */
        exports.bar = function () {
            // TODO
        };
        return exports;
    }
);
```

**[强制] 对于已使用 **`**@module**`** 标识为 AMD模块 的引用，在 **`**namepaths**`** 中必须增加 **`**module:**`** 作前缀。**

解释：

namepaths 没有 module: 前缀时，生成的文档中将无法正确生成链接。

示例：

```javascript
/**
 * 点击处理
 *
 * @fires module:Select#change
 * @private
 */
Select.prototype.clickHandler = function () {
    /**
     * 值变更时触发
     *
     * @event module:Select#change
     * @param {Object} e e描述
     * @param {string} e.before before描述
     * @param {string} e.after after描述
     */
    this.fire(
        'change',
        {
            before: 'foo',
            after: 'bar'
        }
    );
};
```

**[建议] 对于类定义的模块，可以使用 **`**@alias**`** 标识构建函数。**

示例：

```javascript
/**
 * A module representing a jacket.
 * @module jacket
 */
define(
    function () {

        /**
         * @class
         * @alias module:jacket
         */
        var Jacket = function () {
        };

        return Jacket;
    }
);
```

**[建议] 多模块定义时，可以使用 **`**@exports**`** 标识各个模块。**

示例：

```javascript
// one module
define('html/utils',
    /**
     * Utility functions to ease working with DOM elements.
     * @exports html/utils
     */
    function () {
        var exports = {
        };

        return exports;
    }
);

// another module
define('tag',
    /** @exports tag */
    function () {
        var exports = {
        };

        return exports;
    }
);
```

**[建议] 对于 exports 为 Object 的模块，可以使用**`**@namespace**`**标识。**

解释：

使用 [@namespace ](/namespace ) 而不是 [@module ](/module ) 或 [@exports ](/exports ) 时，对模块的引用可以省略 module: 前缀。 

**[建议] 对于 exports 为类名的模块，使用 **`**@class**`** 和 **`**@exports**`** 标识。**

示例：

```javascript

// 只使用 @class Bar 时，类方法和属性都必须增加 @name Bar#methodName 来标识，与 @exports 配合可以免除这一麻烦，并且在引用时可以省去 module: 前缀。
// 另外需要注意类名需要使用 var 定义的方式。

/**
 * Bar description
 *
 * @see foo
 * @exports  Bar
 * @class
 */
var Bar = function () {
    // TODO
};

/**
 * baz description
 *
 * @return {(string|Array)} return description
 */
Bar.prototype.baz = function () {
    // TODO
};
```

#### 细节注释
对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。

**[建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。**

示例：

```javascript
function foo(p1, p2, opt_p3) {
    // 这里对具体内部逻辑进行说明
    // 说明太长需要换行
    for (...) {
        ....
    }
}
```

**[强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：**

解释：

1. TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。
2. FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。
3. HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。
4. XXX: 该处存在陷阱。此时需要对陷阱进行描述。

# vue规范
## vue开发规范
<font style="color:rgb(37, 41, 51);">vue 项目规范以 Vue 官方规范 （</font>[cn.vuejs.org/style-guide/](https://cn.vuejs.org/style-guide/)<font style="color:rgb(37, 41, 51);">） 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</font>

_<font style="color:rgb(37, 41, 51);">请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</font>_

### 命名规范
**<font style="color:rgb(51, 51, 51);">[强制] 组件名使用大驼峰命名法。</font>**

<font style="color:rgb(37, 41, 51);">正例：</font>

```javascript
export default {
  name: 'TodoItem'
  // ...
};
```

 <font style="color:rgb(37, 41, 51);">反例：</font>

```javascript
export default {
  name: 'todo-item',
  // ...
}
```

**<font style="color:rgb(37, 41, 51);">[强制] 组件文件目录则采用组件名称命名，并且采用大驼峰命名</font>**

**<font style="color:rgb(37, 41, 51);">.vue文件除了index.vue文件一律大驼峰方式命名如：MyView.vue</font>**

正例：

```plain
components/
|- MyComponent.vue
```

反例：

```plain
components/
|- my-component.vue
```

**<font style="color:rgb(37, 41, 51);">[强制] 基础组件文件名为 Base 开头，使用完整单词而不是缩写。</font>**

正例：

```plain
components/
|- BaseButton.vue
|- BaseTable.vue
|- BaseIcon.vue
```

反例：

```plain
components/
|- MyButton.vue
|- VueTable.vue
|- Icon.vue
```

**<font style="color:rgb(37, 41, 51);">[强制] 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</font>**

正例：

```plain
components/
|- TodoList.vue
|- TodoListItem.vue
|- TodoListItemButton.vue
```

反例：

```plain
components/
|- TodoList.vue
|- TodoItem.vue
|- TodoButton.vue
```



**<font style="color:rgb(51, 51, 51);">[建议] 组件名称中的单词顺序:组件名称应该以高阶的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</font>**

<font style="color:rgb(51, 51, 51);">正例</font>

```plain
components/
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputQuery.vue
|- SearchInputExcludeGlob.vue
|- SettingCheckboxTerms.vue
|- SettingsCheckboxLaunchOnStartup.vue
```

<font style="color:rgb(51, 51, 51);">反例</font>

```plain
components/
|- ClearSearchButton.vue
|- ExcludeFromSearchInput.vue
|- LaunchOnStartupCheckbox.vue
|- RunSearchButton.vue
|- SearchInput.vue
|- TermsCheckbox.vue
```

### 开发规范
#### data
**<font style="color:rgb(37, 41, 51);">[强制] 组件的 data 必须是一个函数</font>**

<font style="color:rgb(37, 41, 51);">解释：</font>

<font style="color:rgb(37, 41, 51);">当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。因为如果直接是一个对象的话，子组件之间的属性值会互相影响。</font>

正例：

```plain
export default {
  data () {
    return {
      name: 'jack'
    }
  }
}
```

反例：

```plain
export default {
  data: {
    name: 'jack'

}
```

#### prop的定义
**<font style="color:rgb(37, 41, 51);">[强制] Prop 定义应该尽量详细</font>**

+ <font style="color:rgb(37, 41, 51);">必须使用 camelCase 驼峰命名</font>
+ <font style="color:rgb(37, 41, 51);">- 必须指定类型</font>
+ <font style="color:rgb(37, 41, 51);">必须加上注释，表明其含义</font>
+ <font style="color:rgb(37, 41, 51);">必须加上 required 或者 default，两者二选其一</font>
+ <font style="color:rgb(37, 41, 51);">如果有业务需要，必须加上 validator 验证</font>

<font style="color:rgb(51, 51, 51);">在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 </font>[JSX](https://www.w3cschool.cn/vuejs3/vuejs3-erxk3f2q.html)<font style="color:rgb(51, 51, 51);"> 中应该始终使用 kebab-case。</font>

正例：

```plain
props: {
  // 组件状态，用于控制组件的颜色
   status: {
     type: String,
     required: true,
     validator: function (value) {
       return [
         'succ',
         'info',
         'error'
       ].indexOf(value) !== -1
     }
   },
    // 用户级别，用于显示皇冠个数
   userLevel：{
      type: String,
      required: true
   }
}
```

```html
<WelcomeMessage greeting-text="hi"/>
```

#### attribute换行 **<font style="color:rgb(31, 35, 40);">(eslint-plugin-prettier已配置)</font>**
**<font style="color:rgb(51, 51, 51);">[强制] 多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</font>**

#### v-for,v-if和v-show的使用
**<font style="color:rgb(37, 41, 51);">[强制] 必须为 v-for 设置键值 key（eslint-plugin-vue已配置）</font>**

<font style="color:rgb(51, 51, 51);">在组件上总是必须用 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font><font style="color:rgb(51, 51, 51);"> 配合 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for</font><font style="color:rgb(51, 51, 51);">，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的</font>[对象固化 (object constancy)](https://bost.ocks.org/mike/constancy/)<font style="color:rgb(51, 51, 51);"> ，也是一种好的做法。</font>

<font style="color:rgb(51, 51, 51);">正例</font>

```plain
<ul>
  <li
    v-for="todo in todos"
    :key="todo.id"
  >
    {{ todo.text }}
  </li>
</ul>
```

<font style="color:rgb(51, 51, 51);">反例</font>

```plain
<ul>
  <li v-for="todo in todos">
    {{ todo.text }}
  </li>
</ul>
```



**<font style="color:rgb(51, 51, 51);">[强制] 避免 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-if</font>****<font style="color:rgb(51, 51, 51);"> 和 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for</font>****<font style="color:rgb(51, 51, 51);"> 一起使用</font>**

解释：

<font style="color:rgb(51, 51, 51);">永远不要把 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-if</font><font style="color:rgb(51, 51, 51);"> 和 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for</font><font style="color:rgb(51, 51, 51);"> 同时用在同一个元素上。</font>

<font style="color:rgb(51, 51, 51);">一般我们在两种常见的情况下会倾向于这样做：</font>

+ <font style="color:rgb(51, 51, 51);">为了过滤一个列表中的项目 (比如</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for="user in users" v-if="user.isActive"</font><font style="color:rgb(51, 51, 51);">)。在这种情形下，请将</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">users</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">替换为一个计算属性 (比如</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">activeUsers</font><font style="color:rgb(51, 51, 51);">)，让其返回过滤后的列表。</font>
+ <font style="color:rgb(51, 51, 51);">为了避免渲染本应该被隐藏的列表 (比如 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for="user in users" v-if="shouldShowUsers"</font><font style="color:rgb(51, 51, 51);">)。这种情形下，请将 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-if</font><font style="color:rgb(51, 51, 51);"> 移动至容器元素上 (比如 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ul</font><font style="color:rgb(51, 51, 51);">、</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ol</font>

<font style="color:rgb(51, 51, 51);">详解 当 Vue 处理指令时，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">比</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-if</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">具有更高的优先级，所以这个模板：</font>

```plain
<ul>
  <li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```

<font style="color:rgb(51, 51, 51);">将会经过如下运算：</font>

```plain
this.users.map(user => {
  if (user.isActive) {
    return user.name
  }
})
```

<font style="color:rgb(51, 51, 51);">因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。 通过将其更换为在如下的一个计算属性上遍历：</font>

```plain
computed: {
  activeUsers() {
    return this.users.filter(user => user.isActive)
  }
}
```

```plain
<ul>
  <li
    v-for="user in activeUsers"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```

<font style="color:rgb(51, 51, 51);">我们将会获得如下好处：</font>

+ <font style="color:rgb(51, 51, 51);">过滤后的列表</font>_<font style="color:rgb(51, 51, 51);">只</font>_<font style="color:rgb(51, 51, 51);">会在</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">users</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">数组发生相关变化时才被重新运算，过滤更高效。</font>
+ <font style="color:rgb(51, 51, 51);">使用</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for="user in activeUsers"</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">之后，我们在渲染的时候</font>_<font style="color:rgb(51, 51, 51);">只</font>_<font style="color:rgb(51, 51, 51);">遍历活跃用户，渲染更高效。</font>
+ <font style="color:rgb(51, 51, 51);">解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。 为了获得同样的好处，我们也可以把：</font>

```plain
<ul>
<li
v-for="user in users"
v-if="shouldShowUsers"
:key="user.id"
>
{{ user.name }}
</li>
</ul>
```

<font style="color:rgb(51, 51, 51);">更新为：</font>

```plain
<ul v-if="shouldShowUsers">
<li
v-for="user in users"
:key="user.id"
>
{{ user.name }}
</li>
</ul>
```

<font style="color:rgb(51, 51, 51);">通过将 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-if</font><font style="color:rgb(51, 51, 51);"> 移动到容器元素，我们不会再对列表中的每个用户检查 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">shouldShowUsers</font><font style="color:rgb(51, 51, 51);">。取而代之的是，我们只检查它一次，且不会在 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">shouldShowUsers</font><font style="color:rgb(51, 51, 51);"> 为否的时候运算 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for</font><font style="color:rgb(51, 51, 51);">。</font>

**<font style="color:rgb(37, 41, 51);">[建议] v-show 与 v-if 选择</font>**

<font style="color:rgb(37, 41, 51);">解释：</font>

<font style="color:rgb(37, 41, 51);">如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</font>

#### **<font style="color:rgb(37, 41, 51);">指令（eslint-plugin-vue已配置）</font>**
**<font style="color:rgb(37, 41, 51);">[建议] 指令都使用缩写形式</font>**

<font style="color:rgb(37, 41, 51);">解释：</font>

<font style="color:rgb(37, 41, 51);">指令都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</font>

<font style="color:rgb(37, 41, 51);">正例：</font>

```plain
<input
  @input="onInput"
  @focus="onFocus"
>
```

<font style="color:rgb(37, 41, 51);">反例：</font>

```plain
<input
  v-on:input="onInput"
  @focus="onFocus"
>
```

#### 样式作用域
**<font style="color:rgb(37, 41, 51);">[强制] 为组件样式设置作用域</font>**

<font style="color:rgb(37, 41, 51);">解释：</font>

<font style="color:rgb(51, 51, 51);">对于应用来说，顶级 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">App</font><font style="color:rgb(51, 51, 51);"> 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。</font>

<font style="color:rgb(51, 51, 51);">这条规则只和</font>[单文件组件](https://www.w3cschool.cn/vuejs3/vuejs3-q37j3f2y.html)<font style="color:rgb(51, 51, 51);">有关。你</font>_<font style="color:rgb(51, 51, 51);">不一定</font>_<font style="color:rgb(51, 51, 51);">要使用</font><font style="color:rgb(51, 51, 51);"> </font>[scopedattribute](https://vue-loader.vuejs.org/en/features/scoped-css.html)<font style="color:rgb(51, 51, 51);">。设置作用域也可以通过</font><font style="color:rgb(51, 51, 51);"> </font>[CSS Modules](https://vue-loader.vuejs.org/en/features/css-modules.html)<font style="color:rgb(51, 51, 51);">，那是一个基于 class 的类似</font><font style="color:rgb(51, 51, 51);"> </font>[BEM](http://getbem.com/)<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">的策略，当然你也可以使用其它的库或约定。</font>

<font style="color:rgb(51, 51, 51);"></font>

<font style="color:rgb(51, 51, 51);">不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scoped</font><font style="color:rgb(51, 51, 51);"> attribute。</font>

<font style="color:rgb(51, 51, 51);">这让覆写内部样式更容易：使用了人类可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。</font>

正例：

```plain
<template>
  <button class="btn btn-close">X</button>
</template>
<!-- 使用 `scoped` 特性 -->
<style scoped>
  .btn-close {
    background-color: red;
  }
</style>
```

反例：

```plain
<template>
  <button class="btn btn-close">X</button>
</template>
<!-- 没有使用 `scoped` 特性 -->
<style>
  .btn-close {
    background-color: red;
  }
</style>
```

**<font style="color:rgb(51, 51, 51);">[建议] 元素选择器应该避免在 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scoped</font>****<font style="color:rgb(51, 51, 51);"> 中出现。</font>**

<font style="color:rgb(51, 51, 51);">在 </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">scoped</font><font style="color:rgb(51, 51, 51);"> 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。</font>

<font style="color:rgb(51, 51, 51);">正例</font>

```plain
<template>
  <button class="btn btn-close">×</button>
</template>


<style scoped>
.btn-close {
  background-color: red;
}
</style>
```

<font style="color:rgb(51, 51, 51);">反例</font>

```plain
<template>
  <button>×</button>
</template>


<style scoped>
button {
  background-color: red;
}
</style>
```

#### **<font style="color:rgb(37, 41, 51);">顺序保持一致</font>**
##### **<font style="color:rgb(51, 51, 51);">组件/实例的选项顺序</font>**
**<font style="color:rgb(51, 51, 51);">组件/实例的选项应该有统一的顺序。</font>**

<font style="color:rgb(51, 51, 51);">这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。</font>

1. **<font style="color:rgb(51, 51, 51);">全局感知</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(要求组件以外的知识)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">name</font>
2. **<font style="color:rgb(51, 51, 51);">模板依赖</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(模板内使用的资源)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">components</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">directives</font>
3. **<font style="color:rgb(51, 51, 51);">组合</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(向选项里合并 property)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">extends</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mixins</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">provide</font><font style="color:rgb(51, 51, 51);">/</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">inject</font>
4. **<font style="color:rgb(51, 51, 51);">接口</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(组件的接口)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">inheritAttrs</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">props</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">emits</font>
5. **<font style="color:rgb(51, 51, 51);">组合式 API</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(使用组合式 API 的入口点)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">setup</font>
6. **<font style="color:rgb(51, 51, 51);">Local State</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(原生响应式 property)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">data</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">computed</font>
7. **<font style="color:rgb(51, 51, 51);">事件</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(通过响应式事件触发的回调)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">watch</font>
    - <font style="color:rgb(51, 51, 51);">生命周期钩子 (按照它们被调用的顺序)</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">beforeCreate</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">created</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">beforeMount</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">mounted</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">beforeUpdate</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">updated</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">activated</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">deactivated</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">beforeUnmount</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">unmounted</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">errorCaptured</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">renderTracked</font>
        * <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">renderTriggered</font>
8. **<font style="color:rgb(51, 51, 51);">非响应式的 property</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(不依赖响应性系统的实例 property)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">methods</font>
9. **<font style="color:rgb(51, 51, 51);">渲染</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(组件输出的声明式描述)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">template</font><font style="color:rgb(51, 51, 51);">/</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">render</font>

##### <font style="color:rgb(51, 51, 51);">元素 attribute 的顺序</font>**<font style="color:rgb(37, 41, 51);">（eslint-plugin-vue已配置）</font>**
**<font style="color:rgb(51, 51, 51);">元素 (包括组件) 的 attribute 应该有统一的顺序。</font>**

<font style="color:rgb(51, 51, 51);">这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。</font>

1. **<font style="color:rgb(51, 51, 51);">定义</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(提供组件的选项)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">is</font>
2. **<font style="color:rgb(51, 51, 51);">列表渲染</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(创建多个变化的相同元素)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-for</font>
3. **<font style="color:rgb(51, 51, 51);">条件渲染</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(元素是否渲染/显示)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-if</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-else-if</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-else</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-show</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-cloak</font>
4. **<font style="color:rgb(51, 51, 51);">渲染修饰符</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(改变元素的渲染方式)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-pre</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-once</font>
5. **<font style="color:rgb(51, 51, 51);">全局感知</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(需要超越组件的知识)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">id</font>
6. **<font style="color:rgb(51, 51, 51);">唯一的 Attributes</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(需要唯一值的 attribute)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">ref</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">key</font>
7. **<font style="color:rgb(51, 51, 51);">双向绑定</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(把绑定和事件结合起来)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-model</font>
8. **<font style="color:rgb(51, 51, 51);">其他 Attributes</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(所有普通的绑定或未绑定的 attribute)</font>
9. **<font style="color:rgb(51, 51, 51);">事件</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(组件事件监听器)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-on</font>
10. **<font style="color:rgb(51, 51, 51);">内容</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">(覆写元素的内容)</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-html</font>
    - <font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">v-text</font>

##### <font style="color:rgb(51, 51, 51);">单文件组件的顶级元素的顺序</font>
<font style="color:rgb(37, 41, 51);">单文件组件应该总是让标签顺序保持为如下</font>

正例：

```plain
<template>...</template>
<script>...</script>
<style>...</style>
```

反例：

```plain
<template>...</template>
<style>...</style>
<script>...</script>
```

#### **<font style="color:rgb(37, 41, 51);">在 Template 模版中使用组件时</font>**
**<font style="color:rgb(37, 41, 51);">[强制] 在 Template 模版中使用自定义组件（不包含第三方组件库），应使用 PascalCase 模式，并且使用自闭合组件。</font>**

正例：

```plain
<!-- 在单文件组件、字符串模板和 JSX 中 -->
<MyComponent />
<Row><table :column="data"/></Row>
```

反例：

```plain
<my-component /> <row><table :column="data"/></row>
```

#### <font style="color:rgb(51, 51, 51);">父子组件通信</font>
**<font style="color:rgb(51, 51, 51);">[建议]应该优先通过 prop 和事件进行父子组件之间的通信，而不是 </font>****<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this.$parent</font>****<font style="color:rgb(51, 51, 51);"> 或变更 prop。</font>**

<font style="color:rgb(51, 51, 51);">一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">this.$parent</font><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">能够简化两个深度耦合的组件。</font>

<font style="color:rgb(51, 51, 51);">问题在于，这种做法在很多</font>_<font style="color:rgb(51, 51, 51);">简单</font>_<font style="color:rgb(51, 51, 51);">的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。</font>

### **<font style="color:rgb(37, 41, 51);">Vue Router 规范</font>**
#### **<font style="color:rgb(37, 41, 51);">页面跳转数据传递使用路由参数</font>**
<font style="color:rgb(37, 41, 51);">页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</font>

**正例：**

```javascript
let id = ' 123';
this.$router.push({ name: 'userCenter', query: { id: id } });
```

#### **<font style="color:rgb(37, 41, 51);">使用路由懒加载（延迟加载）机制</font>**
```javascript
{
  path: '/uploadAttachment',
    name: 'uploadAttachment',
    meta: {
    title: '上传附件'
  },
  component: () => import('@/view/components/uploadAttachment/index.vue')
},
```

#### **<font style="color:rgb(37, 41, 51);">router 中的命名规范</font>**
<font style="color:rgb(37, 41, 51);">path尽量与vue文件的目录结构保持一致，因为这样很方便找到对应的文件</font>

<font style="color:rgb(37, 41, 51);">name 命名规范采用KebabCase命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）（动态生成的路由可以不遵循此规则）</font>

```javascript
export const reload = [
  {
    path: '/reload',
    name: 'reload',
    component: Main,
    meta: {
      title: '动态加载',
      icon: 'icon iconfont'
    },
    children: [
      {
        path: '/reload/smart-reload-list',
        name: 'SmartReloadList',
        meta: {
          title: 'SmartReload',
        },
        component: () =>
          import('@/views/reload/smart-reload/smart-reload-list.vue')
      }
    ]
  }
];
```

#### **<font style="color:rgb(37, 41, 51);">router 中的 path 命名规范</font>**
**<font style="color:rgb(37, 41, 51);">path必须以 / 开头，即使是children里的path也要以 / 开头。如下示例</font>**

目的：

<font style="color:rgb(37, 41, 51);">经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件</font>

```javascript
{
  path: '/file',
    name: 'File',
    component: Main,
    meta: {
    title: '文件服务',
      icon: 'ios-cloud-upload'
  },
  children: [
    {
      path: '/file/file-list',
      name: 'FileList',
      component: () => import('@/views/file/file-list.vue')
    },
    {
      path: '/file/file-add',
      name: 'FileAdd',
      component: () => import('@/views/file/file-add.vue')
    },
    {
      path: '/file/file-update',
      name: 'FileUpdate',
      component: () => import('@/views/file/file-update.vue')
    }
  ]
}
```

## vue项目规范
### 使用<font style="color:rgb(33, 53, 71);"> Vue 官方的项目脚手架工具</font>
<font style="color:rgb(33, 53, 71);">在打算创建项目的目录执行以下命令初始化项目</font>

:::tips
<font style="color:rgb(33, 53, 71);">npm create vue@latest</font>

:::

<font style="color:rgb(33, 53, 71);">这一指令将会安装并执行 </font>[create-vue](https://github.com/vuejs/create-vue)<font style="color:rgb(33, 53, 71);">，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示：</font>

```plain
✔ Project name: … <your-project-name>
✔ Add TypeScript? … No / Yes
✔ Add JSX Support? … No / Yes
✔ Add Vue Router for Single Page Application development? … No / Yes
✔ Add Pinia for state management? … No / Yes
✔ Add Vitest for Unit testing? … No / Yes
✔ Add an End-to-End Testing Solution? … No / Cypress / Nightwatch / Playwright
✔ Add ESLint for code quality? … No / Yes
✔ Add Prettier for code formatting? … No / Yes
✔ Add Vue DevTools 7 extension for debugging? (experimental) … No / Yes

Scaffolding project in ./<your-project-name>...
Done.
```

### 目录说明
<font style="color:rgb(37, 41, 51);">目录名按照前面章节提到的命名规范命名，其中 components目录下的 组件文件夹用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</font>

```plain
src                                  源码目录                                    
├─ api                               所有api接口                                 
│  ├─ config                         请求配置信息   
│  │  ├─ http-enum.ts                请求相关的枚举类型 
│  │  └─ service-port.ts             后端微服务模块前缀  
│  ├─ helper                         请求辅助工具  
│  │  ├─ axios-cancel.ts             拦截重复请求 
│  │  ├─ check-status.ts             对各个http错误码做的相关的反馈  
│  │  └─ service-loading.ts          全局请求loading配置
│  ├─ interface                        
│  │  └─ index.ts                      
│  ├─ modules                        各个模块请求接口  
│  │  └─ common                      公共请求接口  
│  │     ├─ application.ts           应用列表  
│  │     ├─ dict.ts                  数据字典  
│  │     ├─ language-item.ts         语言词条  
│  │     ├─ language.ts              语言列表  
│  │     ├─ login.ts                 登录  
│  │     ├─ message-list.ts          消息列表  
│  │     └─ user.ts                  用户  
│  └─ index.ts                       请求封装：请求拦截，响应拦截  
├─ assets                            静态资源，images, icons,
│  ├─ iconfonts                         
│  │  ├─ common                      基础图标            
│  │  └─ menu                        菜单图标            
│  └─ images                                                
├─ components                        公共组件   
│  ├─ Error                          错误页面组件   
│  │  └─ index.vue                     
│  ├─ IncludeChildren                包含下级组件   
│  │  └─ index.vue                     
│  ├─ Slider                         滑动图片验证组件    
│  │  ├─ utils                         
│  │  │  ├─ ase.js                     
│  │  │  └─ util.js                    
│  │  └─ index.vue                     
│  ├─ TwoColPage                     左右布局组件     
│  │  └─ index.vue                     
│  ├─ UserSelect                     选人组件      
│  │  └─ index.vue                     
│  └─ index.ts                         
├─ config                            全局配置   
│  ├─ index.ts                         
│  └─ nprogress.ts                     
├─ directives                       全局指令   
│  ├─ modules                          
│  │  └─ auth.ts                       
│  └─ index.ts                         
├─ hooks                           全局hook    
│  ├─ interface                        
│  │  └─ index.ts                      
│  ├─ useMessage.ts                各种消息提示hook    
│  ├─ useNProgress.ts              页面加载进度条    
│  ├─ usePageLoading.ts            页面loading    
│  ├─ useTheme.ts                  主题设置    
│  └─ useTitle.ts                  系统标题    
├─ languages                       多语言配置    
│  ├─ modules                      语言包    
│  │  ├─ en-us.ts                  英文    
│  │  ├─ zh-hans.ts                简体中文    
│  │  └─ zh-hant.ts                繁体中文    
│  └─ index.ts                         
├─ layouts                         布局    
│  ├─ components                   布局相关的组件    
│  │  ├─ Footer                    页脚    
│  │  │  ├─ index.scss                 
│  │  │  └─ index.vue                  
│  │  ├─ Header                    头部导航    
│  │  │  ├─ components                 
│  │  │  │  ├─ AssemblySize.vue    系统尺寸设置    
│  │  │  │  ├─ CollapseIcon.vue    左侧导航缩放   
│  │  │  │  ├─ Fullscreen.vue      系统全屏切换   
│  │  │  │  ├─ Language.vue        系统语言设置    
│  │  │  │  ├─ Message.vue         导航顶部消息提示    
│  │  │  │  ├─ PasswordDialog.vue  修改密码    
│  │  │  │  ├─ Setting.vue         设置弹窗    
│  │  │  │  └─ Title.vue           系统标题    
│  │  │  └─ ToolBarRight.vue           
│  │  ├─ InnerLink                  内嵌外链   
│  │  │  └─ index.vue                  
│  │  ├─ Main                       页面主要部分   
│  │  │  ├─ components                 
│  │  │  │  └─ Maximize.vue            
│  │  │  ├─ index.scss                 
│  │  │  └─ index.vue                  
│  │  ├─ Menu                       菜单  
│  │  │  └─ SubMenu.vue                
│  │  ├─ NotificationContainer         
│  │  │  └─ index.vue                  
│  │  └─ Tabs                      页签组件    
│  │     ├─ components                 
│  │     │  └─ MoreButton.vue          
│  │     ├─ index.scss                 
│  │     └─ index.vue                  
│  ├─ LayoutClassic                    
│  │  └─ index.vue                     
│  └─ index.vue                        
├─ router                          路由，统一管理    
│  ├─ modules                          
│  │  ├─ dynamic-router.ts         动态路由    
│  │  └─ static-router.ts          静态路由    
│  └─ index.ts                     路由拦截，登录校验，菜单权限校验    
├─ stores                          全局状态管理    
│  ├─ helper                       辅助函数    
│  │  └─ persist.ts                持久缓存封装    
│  ├─ interface                    各个状态的ts类型    
│  │  └─ index.ts                      
│  ├─ modules                          
│  │  ├─ applications.ts           应用列表    
│  │  ├─ auth.ts                   应用code,权限菜单，权限按钮    
│  │  ├─ global.ts                 全局系统配置：语言，主题，大小等    
│  │  ├─ keep-alive.ts             需要缓存的页面    
│  │  ├─ language.ts               当前应用的语言列表和语言包    
│  │  ├─ tabs.ts                   页签    
│  │  ├─ user.ts                   用户    
│  │  └─ websocketStore.ts         消息推送    
│  └─ index.ts                         
├─ styles                          全局样式    
│  ├─ koron                        koron-ui组件库样式覆盖    
│  │  └─ var.scss                      
│  ├─ tailwind                     tailwind 框架样式引用    
│  │  ├─ base.scss                     
│  │  ├─ components.scss               
│  │  └─ utilities.scss                
│  ├─ theme                        系统主题相关样式变量的设置    
│  │  ├─ aside.ts                      
│  │  ├─ header.ts                     
│  │  ├─ menu.ts                       
│  │  └─ primary-type.ts               
│  ├─ common.scss                  全局样式    
│  └─ index.scss                       
├─ typings                         全局ts类型声明    
│  ├─ global.d.ts                      
│  ├─ router.d.ts                      
│  ├─ utils.d.ts                       
│  └─ window.d.ts                      
├─ utils                           工具函数    
│  ├─ is                           各数据类型的判断    
│  │  └─ index.ts                      
│  ├─ color.ts                     颜色混合等相关函数    
│  ├─ dictionary.ts                数据字典    
│  ├─ index.ts                         
│  ├─ key-map.ts                       
│  ├─ router-helper.ts            根据原始数据进行路由生成等相关函数     
│  └─ websocket.ts                     
├─ views                          视图目录                         
│  ├─ home                        首页     
│  │  └─ index.vue                     
│  └─ login                       登录页     
│     ├─ components                    
│     │  ├─ PasswordLogin.vue     密码登录     
│     │  ├─ PhoneLogin.vue        手机验证码登录     
│     │  └─ ResetPassword.vue     重置密码     
│     └─ index.vue                                      
├─ App.vue                             
└─ main.ts                         项目入口    


```

#### <font style="color:rgb(37, 41, 51);">api </font>
+ 文件、变量命名要与后端保持一致。
+ 此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。
+ api 中的方法名字要与后端 api url 尽量保持语义高度一致性。
+ 对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。

**正例：**

后端 url： EmployeeController.java

```plain
/employee/add
/employee/delete/{id}
/employee/update
```

前端： employee.js

```plain
  // 添加员工
  addEmployee: (data) => {
    return postAxios('/employee/add', data)
  },
  // 更新员工信息
  updateEmployee: (data) => {
    return postAxios('/employee/update', data)
  },
    // 删除员工
  deleteEmployee: (employeeId) => {
    return postAxios('/employee/delete/' + employeeId)
   },
```

#### <font style="color:rgb(37, 41, 51);">assets 目录</font>
<font style="color:rgb(37, 41, 51);">assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</font>

```plain
assets                              
├─ iconfonts                        
│  ├─ common                        
│  │  ├─ iconfont.css               
│  │  ├─ iconfont.js                
│  │  ├─ iconfont.json              
│  │  ├─ iconfont.ttf               
│  │  ├─ iconfont.woff              
│  │  └─ iconfont.woff2             
│  └─ menu                          
│     ├─ iconfont.css               
│     ├─ iconfont.js                
│     ├─ iconfont.json              
│     ├─ iconfont.ttf               
│     ├─ iconfont.woff              
│     └─ iconfont.woff2             
└─ images                           
   ├─ 404.png                       
   └─ arrow.png                     
   
```

#### <font style="color:rgb(37, 41, 51);">components 目录</font>
<font style="color:rgb(37, 41, 51);">这里的 components 放置的都是全局公用的一些组件，如上传组件，富文本等等。一些页面级的组件建议还是放在各自views文件下，方便管理。</font>

<font style="color:rgb(37, 41, 51);">此目录应按照组件进行目录划分，除index.vue文件，目录和文件命名为 KebabCase，组件命名规则也为 KebabCase</font>

```plain
components          
├─ Error            
│  └─ index.vue     
├─ IncludeChildren  
│  └─ index.vue     
├─ Slider           
│  ├─ utils         
│  │  ├─ ase.js     
│  │  └─ util.js    
│  └─ index.vue     
├─ TwoColPage       
│  └─ index.vue     
├─ UserSelect       
│  └─ index.vue     
└─ index.ts         

```

#### <font style="color:rgb(37, 41, 51);">config目录</font>
<font style="color:rgb(37, 41, 51);">此目录存放系统设置常量</font>

目录结构：

```plain
config           
├─ index.ts      
└─ nprogress.ts  

```

例子index.ts

```typescript
// ? 全局默认配置项
import type { Theme } from '@/hooks/interface'
import { primaryTypes } from '@/styles/theme/primary-type'

// 登录页地址（默认）
export const LOGIN_URL: string = '/login'
export const UI_COLORS: string[] = ['#4f75e9', '#4aca7d', '#f29d49', '#f25749']
// 默认主题颜色类型
export const DEFAULT_PRIMARY_TYPE: Theme.PrimaryType = 'blue'
// 默认主题颜色
export const DEFAULT_PRIMARY: string = primaryTypes[DEFAULT_PRIMARY_TYPE]['--el-color-primary']

// 路由白名单地址（本地存在的路由 staticRouter.ts 中）
export const ROUTER_WHITE_LIST: string[] = ['/404', '/500', '/login']

// 默认应用ID
export const APP_CODE = 'lab'
// 首页地址（默认）
export const HOME_URL: string = `/${APP_CODE}/home`
```

#### <font style="color:rgb(37, 41, 51);">router 与 store 目录</font>
<font style="color:rgb(37, 41, 51);">这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。</font>

<font style="color:rgb(37, 41, 51);">router 尽量按照 views 中的结构保持一致</font>

<font style="color:rgb(37, 41, 51);">store 按照业务进行拆分不同的 js 文件</font>

#### views
+ <font style="color:rgb(37, 41, 51);">这里建议根据业务模块来划分 views，并且 将views 和 api 两个模块一一对应，从而方便维护</font>

![](https://cdn.nlark.com/yuque/0/2024/webp/38559051/1718262902249-0cb142c3-6778-4e58-9701-d14830a5c3c4.webp)

<font style="color:rgb(37, 41, 51);">如 article 模块下放的都是文章相关的 api，这样不管项目怎么累加，api和views的维护还是清晰的，当然也有一些全区公用的api模块，如upload，remoteSearch等等，这些单独放置在common文件夹下就行。</font>

<font style="color:rgb(37, 41, 51);"></font>

+ <font style="color:rgb(37, 41, 51);">components 中组件要使用 PascalCase 规则</font>

```plain
 views                          视图目录                         
   ├─ home                        首页     
   │  └─ index.vue                     
   └─ login                       登录页     
      ├─ components                    
      │  ├─ PasswordLogin.vue     密码登录     
      │  ├─ PhoneLogin.vue        手机验证码登录     
      │  └─ ResetPassword.vue     重置密码     
      └─ index.vue 
```

### 注释说明
+ 公共组件使用说明
+ api 目录的接口 ts文件必须加注释
+ store 中的 state,  action 等必须加注释
+ vue 文件中的 template 必须加注释，若文件较大添加 start end 注释
+ vue 文件的 方法，每个方法 必须添加注释
+ vue 文件的 变量, 非常见单词要加注释

### 代码质量保证
<font style="color:rgb(37, 41, 51);">集成 </font>**<font style="color:rgb(37, 41, 51);">EditorConfig + Prettier + ESLint+styleLint</font>**<font style="color:rgb(37, 41, 51);"> 组合来实现以上各个语言的代码规范化</font>

<font style="color:rgb(37, 41, 51);">对于项目源码中如何配置各个对应的文件将在公司项目的前端脚手架中有所体现，在代码提交时会自动根据各个代码规范文件检查代码。这里只要求在对应的IDE中安装对应工具插件即可；</font>

<font style="color:rgb(37, 41, 51);">如果想要学习集成教程详情见</font>[<font style="color:#117CEE;">Vue3.x 项目工程环境搭建-代码规范</font>](https://juejin.cn/post/6951649464637636622#heading-10)

### 提交规范
前面我们已经统一代码规范，并且在提交代码时进行强约束来保证仓库代码质量。多人协作的项目中，在提交代码这个环节，也存在一种情况：不能保证每个人对提交信息的准确描述，因此会出现提交信息紊乱、风格不一致的情况。

如果 git commit 的描述信息精准，在后期维护和 Bug 处理时会变得有据可查，项目开发周期内还可以根据规范的提交信息快速生成开发日志，从而方便我们追踪项目和把控进度。

这里，我们使用社区最流行、最知名、最受认可的 Angular 团队提交规范。

![](https://cdn.nlark.com/yuque/0/2024/webp/38559051/1718267311043-b99cc201-bdae-4ccf-a2ea-46c7016a21a3.webp)

<font style="color:rgb(37, 41, 51);">如上图，可以看出这些提交信息都是有固定格式的，下面我们来学习 Angular 规范的 commit message 格式。</font>

#### <font style="color:rgb(37, 41, 51);">commit message 格式规范</font>
commit message 由 Header、Body、Footer 组成。

```plain
css

复制代码<Header>

<Body>

<Footer>
```

##### <font style="color:rgb(37, 41, 51);">Header</font>
<font style="color:rgb(37, 41, 51);">Header 部分包括三个字段 type（必需）、scope（可选）和 subject（必需）。</font>

```plain
xml

复制代码<type>(<scope>): <subject>
```

###### <font style="color:rgb(37, 41, 51);">type</font>
<font style="color:rgb(37, 41, 51);">type 用于说明 commit 的提交类型（必须是以下几种之一）。</font>

| <font style="color:rgb(37, 41, 51);">值</font> | <font style="color:rgb(37, 41, 51);">描述</font> |
| --- | --- |
| <font style="color:rgb(37, 41, 51);">feat</font> | <font style="color:rgb(37, 41, 51);">新增一个功能</font> |
| <font style="color:rgb(37, 41, 51);">fix</font> | <font style="color:rgb(37, 41, 51);">修复一个 Bug</font> |
| <font style="color:rgb(37, 41, 51);">docs</font> | <font style="color:rgb(37, 41, 51);">文档变更</font> |
| <font style="color:rgb(37, 41, 51);">style</font> | <font style="color:rgb(37, 41, 51);">代码格式（不影响功能，例如空格、分号等格式修正）</font> |
| <font style="color:rgb(37, 41, 51);">refactor</font> | <font style="color:rgb(37, 41, 51);">代码重构</font> |
| <font style="color:rgb(37, 41, 51);">perf</font> | <font style="color:rgb(37, 41, 51);">改善性能</font> |
| <font style="color:rgb(37, 41, 51);">test</font> | <font style="color:rgb(37, 41, 51);">测试</font> |
| <font style="color:rgb(37, 41, 51);">build</font> | <font style="color:rgb(37, 41, 51);">变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）</font> |
| <font style="color:rgb(37, 41, 51);">ci</font> | <font style="color:rgb(37, 41, 51);">更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等</font> |
| <font style="color:rgb(37, 41, 51);">chore</font> | <font style="color:rgb(37, 41, 51);">变更构建流程或辅助工具</font> |
| <font style="color:rgb(37, 41, 51);">revert</font> | <font style="color:rgb(37, 41, 51);">代码回退</font> |


###### <font style="color:rgb(37, 41, 51);">scope</font>
<font style="color:rgb(37, 41, 51);">scope 用于指定本次 commit 影响的范围。scope 依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。（scope 可省略）</font>

###### <font style="color:rgb(37, 41, 51);">subject</font>
<font style="color:rgb(37, 41, 51);">subject 是本次 commit 的简洁描述，长度约定在 50 个字符以内，通常遵循以下几个规范：</font>

+ <font style="color:rgb(37, 41, 51);">用动词开头，第一人称现在时表述，例如：change 代替 changed 或 changes</font>
+ <font style="color:rgb(37, 41, 51);">第一个字母小写</font>
+ <font style="color:rgb(37, 41, 51);">结尾不加句号（.）</font>

##### <font style="color:rgb(37, 41, 51);">Body</font>
<font style="color:rgb(37, 41, 51);">body 是对本次 commit 的详细描述，可以分成多行。（body 可省略）</font>

<font style="color:rgb(37, 41, 51);">跟 subject 类似，用动词开头，body 应该说明修改的原因和更改前后的行为对比。</font>

##### <font style="color:rgb(37, 41, 51);">Footer</font>
<font style="color:rgb(37, 41, 51);">如果本次提交的代码是突破性的变更或关闭缺陷，则 Footer 必需，否则可以省略。</font>

+ <font style="color:rgb(37, 41, 51);">突破性的变更</font>

<font style="color:rgb(37, 41, 51);">当前代码与上一个版本有突破性改变，则 Footer 以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动的理由。</font>

+ <font style="color:rgb(37, 41, 51);">关闭缺陷</font>

<font style="color:rgb(37, 41, 51);">如果当前提交是针对特定的 issue，那么可以在 Footer 部分填写需要关闭的单个 issue 或一系列 issues。</font>

##### <font style="color:rgb(37, 41, 51);">参考例子</font>
+ <font style="color:rgb(37, 41, 51);">feat</font>

```plain
vbnet

复制代码feat(browser): onUrlChange event (popstate/hashchange/polling)

Added new event to browser:
- forward popstate event if available
- forward hashchange event if popstate not available
- do polling when neither popstate nor hashchange available

Breaks $browser.onHashChange, which was removed (use onUrlChange instead)
```

+ <font style="color:rgb(37, 41, 51);">fix</font>

```plain
vbnet

复制代码fix(compile): couple of unit tests for IE9

Older IEs serialize html uppercased, but IE9 does not...
Would be better to expect case insensitive, unfortunately jasmine does
not allow to user regexps for throw expectations.

Closes #392
Breaks foo.bar api, foo.baz should be used instead
```

+ <font style="color:rgb(37, 41, 51);">style</font>

```plain
scss

复制代码style(location): add couple of missing semi colons
```

+ <font style="color:rgb(37, 41, 51);">chore</font>

```plain
scss

复制代码chore(release): v3.4.2
```

##### <font style="color:rgb(37, 41, 51);">规范 commit message 的好处</font>
+ <font style="color:rgb(37, 41, 51);">首行就是简洁实用的关键信息，方便在 git history 中快速浏览。</font>
+ <font style="color:rgb(37, 41, 51);">具有更加详细的 body 和 footer，可以清晰的看出某次提交的目的和影响。</font>
+ <font style="color:rgb(37, 41, 51);">可以通过 type 过滤出想要查找的信息，也可以通过关键字快速查找相关提交。</font>
+ <font style="color:rgb(37, 41, 51);">可以直接从 commit 生成 change log。</font>

#### <font style="color:rgb(37, 41, 51);">实现规范提交和验证提交</font>
<font style="color:rgb(37, 41, 51);">公司项目的前端脚手架中已</font><font style="color:rgb(37, 41, 51);">集成 Commitizen 实现规范提交和集成了 commitlint 来验证提交规范；使用脚手架建项目时会自动实现代码提交时验证提交规范；</font>

<font style="color:rgb(37, 41, 51);">集成教程详情见</font>[<font style="color:#117CEE;">Vue3.x 项目工程环境搭建-提交规范</font>](https://juejin.cn/post/6951649464637636622#heading-28)

# 附录
### <font style="color:rgb(37, 41, 51);">命名分类</font>
+ camelCase（驼峰式，也叫小驼峰命名，e.g. userInfo）
+ PascalCase（帕斯卡命名式，也叫大驼峰命名，e.g. UserInfo）
+ kebab-case（短横线连接式，e.g. user-info）
+ snake_case（下划线连接式，e.g. user_info）



### **<font style="color:rgb(68, 68, 68);">HTML元素共有以下5种：</font>**
+ <font style="color:rgb(68, 68, 68);">空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</font>
+ <font style="color:rgb(68, 68, 68);">原始文本元素：script、style</font>
+ <font style="color:rgb(68, 68, 68);">RCDATA元素：textarea、title</font>
+ <font style="color:rgb(68, 68, 68);">外来元素：来自MathML命名空间和SVG命名空间的元素。</font>
+ <font style="color:rgb(68, 68, 68);">常规元素：其他HTML允许的元素都称为常规元素。</font>

### <font style="color:rgb(68, 68, 68);">BEM</font>
BEM 是由 Yandex 团队提出的一种 CSS 命名方法论，即 Block（块）、Element（元素）、和 Modifier（修改器）的简称，是 OOCSS 方法论的一种实现模式，底层仍然是面向对象的思想。下面我们从 Element Plus 的 Tabs 组件进行讲解 BEM 的核心思想。

![](https://cdn.nlark.com/yuque/0/2024/webp/38559051/1733822951528-09cf5edb-28d9-45a4-9e85-a9b567ff3a5c.webp)

  


那么整一个组件模块就是一个 Block（块），classname 取名为：el-tabs。Block 代表一个逻辑或功能独立的组件，是一系列结构、表现和行为的封装。 其中每个一个切换的标签就是一个 Element（元素），classname 取名为：el-tabs__item。Element（元素）可以理解为块里的元素。 Modifier（修改器）用于描述一个 Block 或者 Element 的表现或者行为。例如我们需要对两个 Block（块） 或者两个 Element（元素）进行样式微调，那么我们就需要通过 Modifier（修改器），Modifier（修改器）只能作用于 Block（块）或者 Element（元素），Modifier（修改器）是不能单独存在的

BEM 规范下 classname 的命名格式为：

```plain
block-name__<element-name>--<modifier-name>_<modifier_value>
```

+ 所有实体的命名均使用小写字母，复合词使用连字符 “-” 连接。
+ Block 与 Element 之间使用双下画线 “__” 连接。
+ Mofifier 与 Block/Element 使用双连接符 “--” 连接。
+ modifier-name 和 modifier_value 之间使用单下画线 “_” 连接。

### CSS属性分类
+ Formatting Model 相关属性包括：`position` / `top` / `right` / `bottom` / `left` / `float` / `display` / `overflow` 等
+ Box Model 相关属性包括：`border` / `margin` / `padding` / `width` / `height` 等
+ Typographic 相关属性包括：`font` / `line-height` / `text-align` / `word-wrap` 等
+ Visual 相关属性包括：`background` / `color` / `transition` / `list-style` 等

### IIFE
IIFE = Immediately-Invoked Function Expression.立即执行函数

### js数据类型
+ 原始类型: 存取原始类型直接作用于值本身 
    - 布尔类型
    - Null 类型
    - Undefined 类型
    - 数字类型
    - BigInt 类型
    - 字符串类型
    - 符号类型 Symbol

```javascript
const foo = 1
let bar = foo

bar = 9

console.log(foo, bar) // 1, 9
```

+  复杂类型: 访问复杂类型作用于值的引用 
    - object
    - array
    - function

```javascript
const foo = [1, 2, 3]
const bar = foo

bar[0] = 9

console.log(foo[0], bar[0]) // 9, 9
```


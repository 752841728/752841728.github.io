title: 前端开发框架使用指南
author: Funny Boy
date: 2025-02-05 15:27:17
tags: ["Vue"]
categories: ["前端"]

---

# 第一部分:框架代码获取
## 介绍
### 简介
[Ebs Vue3 Template](https://gitee.com/funny_boy/ebs_vue3_template) 一款基于 Vue3.3、TypeScript、Vite5、Pinia、Element-Plus的前端模板框架，使用目前最新技术栈开发。项目提供了登录页面，错误页面，左右布局组件，选人组件等在一定程度上节省您的开发效率。另外本项目还封装了一些常用组件、hooks、指令、动态路由、按钮级别权限控制等功能。

### 需要掌握的基础知识
+ 本项目基于 Vue3.3、Vite5、TS、Pinia、Element-Plus，Vxe Table 开发，并全部采用了的单文件组件 `＜script setup＞` 写法。
+ 建议您在开发前先学习以下内容，提前了解和学习这些知识，会对项目理解非常有帮助：
    - [Vue3 文档](https://cn.vuejs.org/guide/introduction.html)
    - [Vue-Router 文档](https://router.vuejs.org/zh/guide/)
    - [Vite 文档](https://cn.vitejs.dev/guide/)
    - [TypeScript 文档](https://www.typescriptlang.org/zh/docs/)
    - [Pinia 文档](https://pinia.web3doc.top/introduction.html)
    - [Element-Plus 文档](https://element-plus.org/zh-CN/component/button.html)
    - [Vxe Table 文档](https://vxetable.cn/v4/#/component/table/base/basic)
    - [koron-ui文档](http://10.11.228.190:8889/)
    - [ES6 教程](https://es6.ruanyifeng.com/)
    - [tailwindcss文档](https://www.tailwindcss.cn/docs/installation)

### 关于版本更新
+ 本项目后期将会经历不断的更新迭代，后期尽量不进行破坏性更新。对于大多数前端项目框架，它们无法像 npm 包那样平滑的升级版本，因此我们为此给出一些升级的建议。
+ 在编写代码时，应尽量避免修改核心部分。如果业务需要对框架核心内容进行修改，请记录下修改内容，以免在之后的升级过程中被覆盖掉。

### 浏览器支持
+ 本地开发推荐使用 Chrome 最新版浏览器 [Download](https://www.google.com/intl/zh-CN/chrome/)。
+ 生产环境支持现代浏览器，不在支持 IE 浏览器，更多浏览器可以查看 [Can I Use Es Module](https://caniuse.com/?search=ESModule)。

| ![](https://raw.githubusercontent.com/alrra/browser-logos/master/src/archive/internet-explorer_9-11/internet-explorer_9-11_48x48.png)IE | ![](https://raw.githubusercontent.com/alrra/browser-logos/master/src/edge/edge_48x48.png)Edge | ![](https://raw.githubusercontent.com/alrra/browser-logos/master/src/firefox/firefox_48x48.png)Firefox | ![](https://raw.githubusercontent.com/alrra/browser-logos/master/src/chrome/chrome_48x48.png)Chrome | ![](https://raw.githubusercontent.com/alrra/browser-logos/master/src/safari/safari_48x48.png)Safari |
| :---: | :---: | :---: | :---: | :---: |
| not support | last 2 versions | last 2 versions | last 2 versions | last 2 versions |


## 快速上手（重点）
本章节会帮助你从头启动、搭建此项目

### 环境准备
本地环境需要安装 [Node.js 20.x+](https://nodejs.org/en/)、[Git](https://git-scm.com/)

:::warning
Node.js 版本推荐安装 **20+** 以上，版本过低依赖包可能安装失败。

默认使用 npm 作为安装依赖包工具，使用 yarn、npm 没有 lock 可能会安装到最新版依赖。

:::

### 工具配置
本项目推荐使用 VSCode 进行开发，项目里面已内置 VSCode 配置，包含推荐的插件和设置。

> 🌈 推荐安装以下插件：
>

+ [Vue Language Features (Volar)](https://marketplace.visualstudio.com/items?itemName=Vue.volar) ==> Vue3 官方插件
+ [TypeScript Vue Plugin (Volar)](https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin) ==> Vue3 官方插件（TypeScript）
+ [Vue 3 Snippets](https://marketplace.visualstudio.com/items?itemName=hollowtree.vue-snippets) ==> Vue3 代码提示
+ [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) ==> 代码检查
+ [Stylelint](https://marketplace.visualstudio.com/items?itemName=stylelint.vscode-stylelint) ==> CSS 代码检查 && 格式化
+ [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) ==> 代码格式化
+ [EditorConfig for VS Code](https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig) ==> 统一不同编辑器的编码风格
+ [Sass](https://marketplace.visualstudio.com/items?itemName=Syler.sass-indented) ==> Sass 样式编写
+ [DotENV](https://marketplace.visualstudio.com/items?itemName=mikestead.dotenv) ==> 高亮 .env 文件
+ [Git Graph](https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph) ==> <font style="color:rgb(51, 51, 51);">提供一个直观、高效的Git仓库图形化视图</font>
+ [i18n Ally](https://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-ally)==> <font style="color:rgb(51, 51, 51);">在国际化项目中，i18n Ally可以帮助开发者在编辑器中根据项目中的文件来翻译字段，解决中英文翻译对照造成的不便‌</font>

#### .vscode > extensions.json
```json
{
  "recommendations": ["Vue.volar", "dbaeumer.vscode-eslint", "esbenp.prettier-vscode"]
}
```

#### .vscode > settings.json
```json
{
  "editor.codeActionsOnSave": {
    "source.fixAll": "explicit"
  },
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "i18n-ally.localesPaths": ["src/languages/modules"],
  "i18n-ally.enabledParsers": ["ts"],
  "i18n-ally.displayLanguage": "zh-hans",
  "i18n-ally.keystyle": "nested"
}
```

:::warning
+ 开发 Vue3 项目请开启 Volar 插件、禁用 Vetur 插件。
+ 请配置项目默认格式化程序为 Prettier。

:::

### 代码拉取
#### 从 GitLab 拉取代码：
```bash

git clone http://10.11.3.132:8082/platform/ebs_vue3_template.git
```

### 安装使用步骤
#### 安装依赖：
```bash
# 使用 npm
npm install
```

#### 运行项目：
```bash
# 运行项目
npm dev
```

#### 打包项目：
```bash
# 生产环境
npm run build
```

#### 校验、格式化代码：
```bash
# eslint 检测代码
npm run lint:script

# prettier 格式化代码
npm run format

# stylelint 格式化样式
npm run lint:style
```

#### 提交代码：
```bash
# 提交代码（提交前会自动执行 lint:lint-staged 命令）
npm run commit
```

### npm script 详解
```json
{
  "scripts": {
    // 本地运行(dev环境)
    "dev": "vite",
    // 构建打包(pro环境)
    "build": "vue-tsc && vite build --mode production",
    // 预览
    "preview": "vite preview",
    // 检查项目 ts 类型
    "type:check": "vue-tsc --noEmit --skipLibCheck",
    // 执行 eslint 校验
    "lint:script": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore",
    // 执行 prettier 格式化
    "format": "prettier --write src/",
    // 执行 stylelint 格式化
    "lint:style": "stylelint src/**/*.{html,vue,css,less,scss,sass} --fix",
    // 执行 lint-staged.config.js 文件下的命令
    "lint:lint-staged": "lint-staged",
    // 初始化 husky 配置
    "prepare": "husky install",
    // 提交代码(可自定义配置执行命令)
    "commit": "git pull && git add -A && git-cz && git push"
  }
}
```

## 目录结构
### EbsVue3Template目录说明 📚
```plain
ebs_vue3_template
├─ .husky                 # husky 配置文件
├─ .vscode                # VSCode 推荐配置
├─ public                 # 静态资源文件（该文件夹不会被打包）
├─ src
│  ├─ api                 # API 接口管理
│  ├─ assets              # 静态资源文件
│  ├─ components          # 全局组件
│  ├─ config              # 全局配置项
│  ├─ directives          # 全局指令文件
│  ├─ hooks               # 常用 Hooks 封装
│  ├─ languages           # 语言国际化 i18n
│  ├─ layouts             # 框架布局模块
│  ├─ routers             # 路由管理
│  ├─ stores              # pinia store
│  ├─ styles              # 全局样式文件
│  ├─ typings             # 全局 ts 声明
│  ├─ utils               # 常用工具库
│  ├─ views               # 项目所有页面
│  ├─ App.vue             # 项目主组件
│  └─ main.ts             # 项目入口文件
├─ .commitlintrc.cjs      # git 提交规范配置
├─ .editorconfig          # 统一不同编辑器的编码风格
├─ .env                   # vite 常用配置
├─ .env.development       # 开发环境配置
├─ .env.production        # 生产环境配置
├─ .env.test              # 测试环境配置
├─ .eslintignore          # 忽略 Eslint 校验
├─ .eslintrc.cjs          # Eslint 校验配置文件
├─ .gitignore             # 忽略 git 提交
├─ .prettierignore        # 忽略 Prettier 格式化
├─ .prettierrc.cjs        # Prettier 格式化配置
├─ .stylelintignore       # 忽略 stylelint 格式化
├─ .stylelintrc.cjs       # stylelint 样式格式化配置
├─ Dockerfile                                  
├─ env.d.ts								# 指定 ts 识别 vue
├─ index.html             # 入口 html
├─ lint-staged.config.cjs # lint-staged 配置文件
├─ package-lock.json      # 依赖包包版本锁
├─ package.json           # 依赖包管理
├─ postcss.config.js      # postcss 配置
├─ README.md              # README 介绍
├─ tailwind.config.js     # tailwind 配置                     
├─ tsconfig.app.json                          
├─ tsconfig.json          # typescript 全局配置                     
├─ tsconfig.node.json     
└─ vite.config.ts         # vite 全局配置文件                   
```



### src目录说明
```plain
src                                  源码目录                                    
├─ api                               所有api接口                                 
│  ├─ config                         请求配置信息   
│  │  ├─ http-enum.ts                请求相关的枚举类型 
│  │  └─ service-port.ts             后端微服务模块前缀  
│  ├─ helper                         请求辅助工具  
│  │  ├─ axios-cancel.ts             拦截重复请求 
│  │  ├─ check-status.ts             对各个http错误码做的相关的反馈  
│  │  └─ service-loading.ts          全局请求loading配置
│  ├─ interface                        
│  │  └─ index.ts                      
│  ├─ modules                        各个模块请求接口  
│  │  └─ common                      公共请求接口  
│  │     ├─ application.ts           应用列表  
│  │     ├─ dict.ts                  数据字典  
│  │     ├─ language-item.ts         语言词条  
│  │     ├─ language.ts              语言列表  
│  │     ├─ login.ts                 登录  
│  │     ├─ message-list.ts          消息列表  
│  │     └─ user.ts                  用户  
│  └─ index.ts                       请求封装：请求拦截，响应拦截  
├─ assets                            静态资源，images, icons,
│  ├─ iconfonts                         
│  │  ├─ common                      基础图标            
│  │  └─ menu                        菜单图标            
│  ├─ images 
│  └─ json                           静态模拟数据
│     └─ auth-info.json              本地权限菜单数据
├─ components                        公共组件   
│  ├─ Error                          错误页面组件   
│  │  └─ index.vue                     
│  ├─ IncludeChildren                包含下级组件   
│  │  └─ index.vue                     
│  ├─ Slider                         滑动图片验证组件    
│  │  ├─ utils                         
│  │  │  ├─ ase.js                     
│  │  │  └─ util.js                    
│  │  └─ index.vue                     
│  ├─ TwoColPage                     左右布局组件     
│  │  └─ index.vue                     
│  ├─ UserSelect                     选人组件      
│  │  └─ index.vue                     
│  └─ index.ts                         
├─ config                            全局配置   
│  ├─ index.ts                         
│  └─ nprogress.ts                     
├─ directives                       全局指令   
│  ├─ modules                          
│  │  └─ auth.ts                       
│  └─ index.ts                         
├─ hooks                           全局hook    
│  ├─ interface                        
│  │  └─ index.ts                      
│  ├─ useMessage.ts                各种消息提示hook    
│  ├─ useNProgress.ts              页面加载进度条    
│  ├─ usePageLoading.ts            页面loading    
│  ├─ useTheme.ts                  主题设置    
│  └─ useTitle.ts                  系统标题    
├─ languages                       多语言配置    
│  ├─ modules                      语言包    
│  │  ├─ en-us.ts                  英文    
│  │  ├─ zh-hans.ts                简体中文    
│  │  └─ zh-hant.ts                繁体中文    
│  └─ index.ts                         
├─ layouts                         布局    
│  ├─ components                   布局相关的组件    
│  │  ├─ Footer                    页脚    
│  │  │  ├─ index.scss                 
│  │  │  └─ index.vue                  
│  │  ├─ Header                    头部导航    
│  │  │  ├─ components                 
│  │  │  │  ├─ AssemblySize.vue    系统尺寸设置    
│  │  │  │  ├─ CollapseIcon.vue    左侧导航缩放   
│  │  │  │  ├─ Fullscreen.vue      系统全屏切换   
│  │  │  │  ├─ Language.vue        系统语言设置    
│  │  │  │  ├─ Message.vue         导航顶部消息提示    
│  │  │  │  ├─ PasswordDialog.vue  修改密码    
│  │  │  │  ├─ Setting.vue         设置弹窗    
│  │  │  │  └─ Title.vue           系统标题    
│  │  │  └─ ToolBarRight.vue           
│  │  ├─ InnerLink                  内嵌外链   
│  │  │  └─ index.vue                  
│  │  ├─ Main                       页面主要部分   
│  │  │  ├─ components                 
│  │  │  │  └─ Maximize.vue            
│  │  │  ├─ index.scss                 
│  │  │  └─ index.vue                  
│  │  ├─ Menu                       菜单  
│  │  │  └─ SubMenu.vue                
│  │  ├─ NotificationContainer         
│  │  │  └─ index.vue                  
│  │  └─ Tabs                      页签组件    
│  │     ├─ components                 
│  │     │  └─ MoreButton.vue          
│  │     ├─ index.scss                 
│  │     └─ index.vue                  
│  ├─ LayoutClassic                    
│  │  └─ index.vue                     
│  └─ index.vue                        
├─ router                          路由，统一管理    
│  ├─ modules                          
│  │  ├─ dynamic-router.ts         动态路由    
│  │  └─ static-router.ts          静态路由    
│  └─ index.ts                     路由拦截，登录校验，菜单权限校验    
├─ stores                          全局状态管理    
│  ├─ helper                       辅助函数    
│  │  └─ persist.ts                持久缓存封装    
│  ├─ interface                    各个状态的ts类型    
│  │  └─ index.ts                      
│  ├─ modules                          
│  │  ├─ applications.ts           应用列表    
│  │  ├─ auth.ts                   应用code,权限菜单，权限按钮    
│  │  ├─ global.ts                 全局系统配置：语言，主题，大小等    
│  │  ├─ keep-alive.ts             需要缓存的页面    
│  │  ├─ language.ts               当前应用的语言列表和语言包    
│  │  ├─ tabs.ts                   页签    
│  │  ├─ user.ts                   用户    
│  │  └─ websocketStore.ts         消息推送    
│  └─ index.ts                         
├─ styles                          全局样式    
│  ├─ koron                        koron-ui组件库样式覆盖    
│  │  └─ var.scss                      
│  ├─ tailwind                     tailwind 框架样式引用    
│  │  ├─ base.scss                     
│  │  ├─ components.scss               
│  │  └─ utilities.scss                
│  ├─ theme                        系统主题相关样式变量的设置    
│  │  ├─ aside.ts                      
│  │  ├─ header.ts                     
│  │  ├─ menu.ts                       
│  │  └─ primary-type.ts               
│  ├─ common.scss                  全局样式    
│  └─ index.scss                       
├─ typings                         全局ts类型声明    
│  ├─ global.d.ts                      
│  ├─ router.d.ts                      
│  ├─ utils.d.ts                       
│  └─ window.d.ts                      
├─ utils                           工具函数    
│  ├─ is                           各数据类型的判断    
│  │  └─ index.ts                      
│  ├─ color.ts                     颜色混合等相关函数    
│  ├─ dictionary.ts                数据字典    
│  ├─ index.ts                         
│  ├─ key-map.ts                       
│  ├─ router-helper.ts            根据原始数据进行路由生成等相关函数     
│  └─ websocket.ts                     
├─ views                          视图目录                         
│  ├─ home                        首页     
│  │  └─ index.vue                     
│  └─ login                       登录页     
│     ├─ components                    
│     │  ├─ PasswordLogin.vue     密码登录     
│     │  ├─ PhoneLogin.vue        手机验证码登录     
│     │  └─ ResetPassword.vue     重置密码     
│     └─ index.vue                                      
├─ App.vue                             
└─ main.ts                         项目入口    


```

# 第二部分:框架初始化配置
## 项目规范
本项目推荐使用 **Visual Studio Code** 开发

### 项目规范应用（重要）
#### 项目文件、组件命名规范
与本公司的前端代码规范中规定的各目录及文件命名规范一致：

+ <font style="color:rgb(37, 41, 51);">目录命名：其中 components目录下的 组件文件夹用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名</font>
+ <font style="color:rgb(37, 41, 51);">文件命名：除.vue文件须用大驼峰命名法（index.vue除外），其余文件用kebab-case 命名法</font>

:::warning
💢EbsVue3Template 采用 Vue 官方推荐的风格指南，请务必查看

:::

####  自动格式化
+ 按配置过程要求安装相应的vscode插件，代码中会根据相关代码规范配置进行代码风格，代码质量的错误提示，并可能会给予修改意见；
+ 当保存时，也会把不符合代码风格的地方进行自动格式化和修复；
+ 无法修复的地方会以下波浪线（红色或黄色）提示，开发者可根据提示进行修复

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732704502941-1d7a4d3e-4295-4ae1-be2e-33ad3f039304.png)

#### 提交规范
+ 在提交时要输入的提交信息要按照提交规范输入（相关配置文件见.commitlintrc.cjs），否则会无法提交；
+ <font style="color:rgb(37, 41, 51);">因为已在项目中集成 commitizen，使用了</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">git cz</font>`<font style="color:rgb(37, 41, 51);"> 代替了</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">git commit</font>`<font style="color:rgb(37, 41, 51);"> 建议大家用 </font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">git cz</font>`<font style="color:rgb(37, 41, 51);"> 来代替 </font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">git commit</font>`<font style="color:rgb(37, 41, 51);"> 提交代码；</font>
+ <font style="color:rgb(37, 41, 51);">已配置 package.json 命令commit,所以也可直接运行package.json中的commit 命令</font>`<font style="color:rgb(37, 41, 51);">npm run commit</font>`<font style="color:rgb(37, 41, 51);">可以保证提交信息规范。</font>

### 项目规范配置过程（可忽略不看）
本章节是介绍项目规范配置的全部过程，便于使用者的理解和根据业务需求更改相关配置

#### 代码格式化工具（Prettier）
##### 1、下载 prettier 相关依赖：
```bash
npm install prettier -D
```

##### 2、安装 Vscode 插件（Prettier）：
![](../images/Prettier.png)![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732672764324-6950f6c8-6c39-4155-bbf3-84942a210082.png)

##### 3、配置 Prettier（.prettierrc.json）：
```json
{
  "$schema": "https://json.schemastore.org/prettierrc",
  // 指定最大换行长度
  "printWidth": 120,
  // 缩进制表符宽度 | 空格数
  "tabWidth": 2,
  // 结尾不用分号 (true：有，false：没有)
  "semi": false,
  // 使用单引号 (true：单引号，false：双引号)
  "singleQuote": true,
  // 多行时尽可能打印尾随逗号 可选值"<none|es5|all>"
  "trailingComma": "none",
  // 控制HTML、Vue和JSX元素中每个属性是否单独占据一行
  "singleAttributePerLine": true
}
```

#### 代码规范工具（ESLint）
##### 1、本项目使用到的 ESLint 相关依赖：
由于本项目模板是使用vue官方的项目脚手架<font style="color:rgb(33, 53, 71);"> </font>[create-vue](https://github.com/vuejs/create-vue)搭建的，已内置了相关的eslint配置，其内置的相关的插件如下：

| 依赖 | 作用描述 |
| :---: | :---: |
| eslint | ESLint 核心库 |
| eslint-config-standard | 社区提供的更全面的规则集 |
| eslint-plugin-vue | 为 Vue 使用 ESlint 的插件 |
| @vue/eslint-config-prettier | 解决代码规范与Prettier格式化工具之间的和谐共存问题 |
| @vue/eslint-config-typescript | <font style="color:rgb(77, 77, 77);">专门为Vue-TypeScript项目设计的ESLint配置，它结合了</font>[@typescript-eslint/eslint-plugin](https://typescript-eslint.io/docs/user/configuring)<font style="color:rgb(77, 77, 77);">中的规则，并针对Vue生态进行了优化,是专为Vue CLI和create-vue项目定制的ESLint配置包</font> |
| @rushstack/eslint-patch | <font style="color:rgb(51, 51, 51);">尝试加载一个ESLint的补丁，以解决与现代JavaScript模块解析相关的问题</font> |


上述的插件也是基于下列插件实现的，如果想要手动搭建一遍可以先下载下列插件

```bash
npm install eslint eslint-config-prettier eslint-plugin-prettier eslint-plugin-vue @typescript-eslint/eslint-plugin @typescript-eslint/parser -D
```

| 依赖 | 作用描述 |
| :---: | :---: |
| eslint | ESLint 核心库 |
| eslint-config-prettier | 关掉所有和 Prettier 冲突的 ESLint 的配置 |
| eslint-plugin-prettier | 将 Prettier 的 rules 以插件的形式加入到 ESLint 里面 |
| eslint-plugin-vue | 为 Vue 使用 ESlint 的插件 |
| @typescript-eslint/eslint-plugin | ESLint 插件，包含了各类定义好的检测 TypeScript 代码的规范 |
| @typescript-eslint/parser | ESLint 的解析器，用于解析 TypeScript，从而检查和规范 TypeScript 代码 |


##### 2、安装 Vscode 插件（ESLint）：
![](../images/ESLint.png)![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732674820633-29940747-a2d0-4649-b728-5f72478455f5.png)

##### 3、配置 ESLint（.eslintrc.cjs）：
1、本项目的eslintrc.cjs配置文件如下： 

```javascript
/* eslint-env node */
require('@rushstack/eslint-patch/modern-module-resolution')

module.exports = {
  root: true,
  extends: [
    'plugin:vue/vue3-recommended',
    'eslint:recommended',
    'standard',
    '@vue/eslint-config-typescript',
    '@vue/eslint-config-prettier'
  ],
  /*
   * "off" 或 0    ==>  关闭规则
   * "warn" 或 1   ==>  打开的规则作为警告（不影响代码执行）
   * "error" 或 2  ==>  规则作为一个错误（代码不能执行，界面报错）
   */
  rules: {
    // vue (https://eslint.vuejs.org/rules)
    'vue/multi-word-component-names': 'off' // 关闭“要求组件名称是多单词的”规则
  },
  parserOptions: {
    ecmaVersion: 'latest'
  }
}
```

需要忽略eslint代码检查的文件配置.eslintignore配置如下：

```bash
**.d.ts
dist
node_modules
iconfont.*
```

2、如果项目是基于基础插件手动搭建方式，则eslint的配置可参考如下配置：

```javascript
// @see: http://eslint.cn

module.exports = {
	root: true,
	env: {
		browser: true,
		node: true,
		es6: true,
	},
	// 指定如何解析语法
	parser: "vue-eslint-parser",
	// 优先级低于 parse 的语法解析配置
	parserOptions: {
		parser: "@typescript-eslint/parser",
		ecmaVersion: 2020,
		sourceType: "module",
		jsxPragma: "React",
		ecmaFeatures: {
			jsx: true,
		},
	},
	// 继承某些已有的规则
	extends: ["plugin:vue/vue3-recommended", "plugin:@typescript-eslint/recommended", "plugin:prettier/recommended"],
	/**
	 * "off" 或 0    ==>  关闭规则
	 * "warn" 或 1   ==>  打开的规则作为警告（不影响代码执行）
	 * "error" 或 2  ==>  规则作为一个错误（代码不能执行，界面报错）
	 */
	rules: {
		// eslint (http://eslint.cn/docs/rules)
		"vue/multi-word-component-names": "off", // 要求组件名称始终为 “-” 链接的单词
	},
};
```

#### 样式规范工具（StyleLint）
##### 1、下载 StyleLint 相关依赖：
```bash
npm install stylelint stylelint-config-html stylelint-config-standard-scss stylelint-config-standard-vue stylelint-config-standard stylelint-config-recess-order postcss postcss-html stylelint-prettier -D
```

| 依赖 | 作用描述 |
| :---: | --- |
| stylelint | stylelint 核心库 |
| stylelint-config-standard | 是一个用于Stylelint的共享配置，它提供了一套基础规则，帮助开发者遵循CSS编码的最佳实践。该配置涵盖了从选择器命名到属性排序等多方面的检查，确保你的样式代码保持整洁和一致 |
| stylelint-config-html | Stylelint 的可共享 HTML（和类似 HTML）配置，捆绑 postcss-html 并对其进行配置。 |
| stylelint-config-standard-scss | 扩展 stylelint-config-standard 共享配置，并为 SCSS 配置其规则 |
| stylelint-config-standard-vue | 扩展 stylelint-config-standard  共享配置，并为 Vue 配置其规则 |
| stylelint-config-recess-order | 属性的排序（插件包） |
| stylelint-prettier | 将Prettier的格式化功能集成到Stylelint中，使得开发者可以在保持原有Stylelint配置的基础上，利用Prettier进行代码的自动化格式化 |
| postcss | postcss-html 的依赖包 |
| postcss-html | 用于解析 HTML（和类似 HTML）的 PostCSS 语法 |


##### 2、安装 Vscode 插件（StyleLint）：
![](../images/Stylelint.png)![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732698218523-24274aba-82dd-4d8f-9450-c18a1ee251ea.png)

##### 3、在目录的 .vscode 文件夹下新建 settings.json：
```json
{
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.fixAll.stylelint": true
    },
    "stylelint.enable": true,
    "stylelint.validate": ["css", "less", "postcss", "scss", "vue", "sass", "html"],
    "files.eol": "\n"
}
```

> 😎 也可以在 vscode 中全局配置上述 json 代码 😎
>

##### 4、配置 StyleLint（.stylelintrc.cjs）：
```javascript
module.exports = {
  // 继承一系列规则集合
  extends: [
    'stylelint-config-standard', // 配置stylelint拓展插件
    'stylelint-config-html/vue', // 配置 vue 中 template 样式格式化
    'stylelint-config-standard-scss', // 配置stylelint scss插件
    'stylelint-config-standard-vue/scss', // 配置 vue 中 scss 样式格式化
    'stylelint-config-recess-order', // 配置stylelint css属性书写顺序插件,
    'stylelint-prettier/recommended'
  ],
  overrides: [
    // 扫描 .vue/html 文件中的<style>标签内的样式
    {
      files: ['**/*.{vue,html}'],
      customSyntax: 'postcss-html'
    }
  ],
  /**
   * null  => 关闭该规则
   */
  rules: {
    'selector-class-pattern': null,
    'selector-pseudo-class-no-unknown': [
      true,
      {
        ignorePseudoClasses: ['global', 'v-deep', 'deep']
      }
    ],
    'at-rule-no-unknown': null,
    'scss/at-rule-no-unknown': [
      true,
      {
        ignoreAtRules: ['tailwind', 'tailwindcss'] //tailwindcss相关配置
      }
    ]
  }
}

```

需要忽略stylelint代码检查的文件配置.stylelintignore配置如下：

```bash
/dist/*
node_modules/*
```

#### EditorConfig 配置
##### 1、简介：
+ **EditorConfig** 帮助开发人员在 **不同的编辑器** 和 **IDE** 之间定义和维护一致的编码样式。

##### 2、安装 VsCode 插件（EditorConfig ）：
![](../images/EditorConfig.png)![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732699026813-eb473f7a-031c-4442-9405-35308a42275e.png)

##### 3、配置 EditorConfig（.editorconfig）：
```bash
# @see: http://editorconfig.org

root = true

[*] # 表示所有文件适用
#编码
charset = utf-8
#缩进方式
indent_style = space
#缩进空格数
indent_size = 2
#换行符lf
end_of_line = lf
#是否删除行尾的空格
trim_trailing_whitespace = true
#是否在文件的最后插入一个空行
insert_final_newline = true

[*.md] # 表示仅 md 文件适用以下规则
max_line_length = off # 关闭最大行长度限制
trim_trailing_whitespace = false # 关闭末尾空格修剪

```

#### Git 流程规范配置
| 依赖 | 作用描述 |
| :---: | --- |
| husky | 操作 **git** 钩子的工具（在 **git xx** 之前执行某些命令） |
| lint-staged | <font style="color:rgb(36, 41, 47);">如果在整个项目上进行代码检查那么效率就会非常低下，所以最好的做法就是检查那些被改动了的文件，而 Lint-staged 则可以帮我们实现这个目的:</font>在提交之前进行 **eslint** 校验，并使用 **prettier** 格式化本地暂存区的代码， |
| <font style="color:rgb(36, 41, 47);">pretty-quick</font> | <font style="color:rgb(36, 41, 47);">如果在整个项目上进行代码格式化也是效率非常低下的，我们可以通过 pretty-quick 在更改的文件上运行 Prettier 进行代码格式化</font> |
| @commitlint/cli | 校验 **git commit** 信息是否符合规范，保证团队的一致性 |
| @commitlint/config-conventional | **Anglar** 的提交规范 |
| commitizen | <font style="color:rgb(0, 0, 0);background-color:rgb(201, 228, 255);">基于 Node.js 的 git commit 命令行工具，生成标准化的 message</font> |
| cz-git | 一款工程性更强，轻量级，高度自定义，标准输出格式的 **commitize** 适配器 |


##### 1、husky（操作 git 钩子的工具）：
> **安装：**
>

```bash
npm install husky -D
```

> **使用（为了添加.husky 文件夹）：**
>

```bash
# 编辑 package.json > prepare 脚本并运行一次

npm set-script prepare "husky install"
npm run prepare
```

##### 2、 lint-staged（本地暂存代码检查工具）
> **安装：**
>

```bash
npm install lint-staged --D
```

> **添加 ESlint Hook（在.husky 文件夹下添加 pre-commit 文件）：**
>

> **作用：通过钩子函数，判断提交的代码是否符合规范，并使用 prettier 格式化代码**
>

```bash
npx husky add .husky/pre-commit "npm run lint:lint-staged"
npx husky add .husky/pre-commit "npx pretty-quick --staged"
```

> 新增 **lint-staged.config.cjs** 文件：
>

```javascript
module.exports = {
  '*.{js,jsx,ts,tsx}': ['eslint --fix', 'prettier --write'],
  '{!(package)*.json,*.code-snippets,.!(browserslist)*rc}': ['prettier --write--parser json'],
  'package.json': ['prettier --write'],
  '*.vue': ['eslint --fix', 'prettier --write', 'stylelint --fix'],
  '*.{scss,less,styl,html}': ['stylelint --fix', 'prettier --write'],
  '*.md': ['prettier --write']
}

```

##### 3、commitlint（commit 信息校验工具，不符合则报错）
> **安装：**
>

```bash
npm install @commitlint/cli @commitlint/config-conventional -D
```

> **配置命令（在.husky 文件夹下添加 commit-msg 文件）：**
>

```bash
npx husky add .husky/commit-msg 'npx --no-install commitlint --edit "$1"'
```

##### 4、commitizen（基于 Node.js 的 git commit 命令行工具，生成标准化的 message）
```bash
// 安装 commitizen，如此一来可以快速使用 commitizen 命令进行启动。
npm install commitizen -D
```

##### 5、cz-git
> **指定提交文字规范，一款工程性更强，高度自定义，标准输出格式的 commitizen 适配器**
>

```bash
npm install cz-git -D
```

> **配置 package.json：**
>

```bash
"config": {
  "commitizen": {
    "path": "./node_modules/cz-git"
  }
}
```

> **新建 .commitlintrc.cjs 文件：**
>

```javascript
// .commitlintrc.js
/** @type {import('cz-git').UserConfig} */
module.exports = {
  ignores: [(commit) => commit.includes('init')],
  extends: ['@commitlint/config-conventional'],
  rules: {
    // @see: https://commitlint.js.org/#/reference-rules
  },
  prompt: {
    alias: { fd: 'docs: fix typos' },
    messages: {
      type: '选择你要提交的类型 :',
      scope: '选择一个提交范围（可选）:',
      customScope: '请输入自定义的提交范围 :',
      subject: '填写简短精炼的变更描述 :\n',
      body: '填写更加详细的变更描述（可选）。使用 "|" 换行 :\n',
      breaking: '列举非兼容性重大的变更（可选）。使用 "|" 换行 :\n',
      footerPrefixesSelect: '选择关联issue前缀（可选）:',
      customFooterPrefix: '输入自定义issue前缀 :',
      footer: '列举关联issue (可选) 例如: #31, #I3244 :\n',
      confirmCommit: '是否提交或修改commit ?'
    },
    types: [
      { value: 'feat', name: 'feat:     新增功能 | A new feature' },
      { value: 'fix', name: 'fix:      修复缺陷 | A bug fix' },
      { value: 'docs', name: 'docs:     文档更新 | Documentation only changes' },
      { value: 'style', name: 'style:    代码格式 | Changes that do not affect the meaning of the code' },
      { value: 'refactor', name: 'refactor: 代码重构 | A code change that neither fixes a bug nor adds a feature' },
      { value: 'perf', name: 'perf:     性能提升 | A code change that improves performance' },
      { value: 'test', name: 'test:     测试相关 | Adding missing tests or correcting existing tests' },
      { value: 'build', name: 'build:    构建相关 | Changes that affect the build system or external dependencies' },
      { value: 'ci', name: 'ci:       持续集成 | Changes to our CI configuration files and scripts' },
      { value: 'revert', name: 'revert:   回退代码 | Revert to a commit' },
      { value: 'chore', name: 'chore:    其他修改 | Other changes that do not modify src or test files' }
    ],
    useEmoji: false,
    emojiAlign: 'center',
    useAI: false,
    aiNumber: 1,
    themeColorCode: '',
    scopes: [],
    allowCustomScopes: true,
    allowEmptyScopes: true,
    customScopesAlign: 'bottom',
    customScopesAlias: 'custom',
    emptyScopesAlias: 'empty',
    upperCaseSubject: false,
    markBreakingChangeMode: false,
    allowBreakingChanges: ['feat', 'fix'],
    breaklineNumber: 100,
    breaklineChar: '|',
    skipQuestions: ['body', 'footer'],
    issuePrefixes: [
      // 如果使用 gitee 作为开发管理
      { value: 'link', name: 'link:     链接 ISSUES 进行中' },
      { value: 'closed', name: 'closed:   标记 ISSUES 已完成' }
    ],
    customIssuePrefixAlign: 'top',
    emptyIssuePrefixAlias: 'skip',
    customIssuePrefixAlias: 'custom',
    allowCustomIssuePrefix: true,
    allowEmptyIssuePrefix: true,
    confirmColorize: true,
    scopeOverrides: undefined,
    defaultBody: '',
    defaultIssues: '',
    defaultScope: '',
    defaultSubject: ''
  }
}

```

#### 配置 package.json 命令
```json
{
    "scripts": {
        // 本地运行(dev环境)
        "dev": "vite",
        // 本地运行(dev环境)
        "serve": "vite",
        // 构建打包(dev环境)
        "build:dev": "vue-tsc && vite build --mode development",
        // 构建打包(test环境)
        "build:test": "vue-tsc && vite build --mode test",
        // 构建打包(pro环境)
        "build:pro": "vue-tsc && vite build --mode production",
        // 检查项目 ts 类型
        "type:check": "vue-tsc --noEmit --skipLibCheck",
        // 本地环境预览构建后的 dist
        "preview": "npm run build:dev && vite preview",
        // 执行 eslint 校验
        "lint:eslint": "eslint --fix --ext .js,.ts,.vue ./src",
        // 执行 prettier 格式化
        "lint:prettier": "prettier --write \"src/**/*.{js,ts,json,tsx,css,less,scss,vue,html,md}\"",
        // 执行 stylelint 格式化
        "lint:stylelint": "stylelint --cache --fix \"**/*.{vue,less,postcss,css,scss}\" --cache --cache-location node_modules/.cache/stylelint/",
        // 执行 lint-staged.config.js 文件下的命令
        "lint:lint-staged": "lint-staged",
        // 初始化 husky 配置
        "prepare": "husky install",
        // 自动更新版本
        "release": "standard-version",
        // 提交代码(可自定义配置执行命令)
        "commit": "git add -A && czg && git push"
    }
}
```

## 全局配置
### 系统全局变量配置
在 src/config/index.ts文件中可对项目的一些全局配置根据业务需求进行重新配置默认值：

```typescript
// ? 全局默认配置项
import type { Theme } from '@/hooks/interface'
import { primaryTypes } from '@/styles/theme/primary-type'

// 登录页地址（默认）
export const LOGIN_URL: string = '/login'
export const UI_COLORS: string[] = ['#4f75e9', '#4aca7d', '#f29d49', '#f25749']
// 默认主题颜色类型
export const DEFAULT_PRIMARY_TYPE: Theme.PrimaryType = 'blue'
// 默认主题颜色
export const DEFAULT_PRIMARY: string = primaryTypes[DEFAULT_PRIMARY_TYPE]['--el-color-primary']

// 路由白名单地址（本地存在的路由 staticRouter.ts 中）
export const ROUTER_WHITE_LIST: string[] = ['/404', '/500', '/login']

// 默认应用ID
export const APP_CODE = 'iot'
// 首页地址（默认）
export const HOME_URL: string = `/${APP_CODE}/home`
```

登录地址，默认主题色；路由白名单，默认首页，系统code

#### LOGIN_URL 登录地址
其中登录地址是以路由的方式进行跳转的。如果业务需求是可能跳转到其他完整链接，可进行全局搜索该变量进行更改跳转方式

#### DEFAULT_PRIMARY_TYPE 默认主题色类型
本项目中有三种主题：主题蓝blue，党建红red，生日金golden，分别对应有不同颜色和导航背景图，相关数据见src/styles/theme/primary-type.ts

```typescript
import type { Theme } from '@/hooks/interface'
import blueUrl from '@/assets/images/header-bg-blue.png'
import blueTopUrl from '@/assets/images/header-bg-blue-top.png'
import blueBottomUrl from '@/assets/images/header-bg-blue-bottom.png'
import redUrl from '@/assets/images/header-bg-red.png'
import redTopUrl from '@/assets/images/header-bg-red-top.png'
import redBottomUrl from '@/assets/images/header-bg-red-bottom.png'
import goldenUrl from '@/assets/images/header-bg-golden.png'
import goldenTopUrl from '@/assets/images/header-bg-golden-top.png'
import goldenBottomUrl from '@/assets/images/header-bg-golden-bottom.png'

export const primaryTypes: Record<Theme.PrimaryType, { [key: string]: string }> = {
  blue: {
    '--kr-color-primary': '#4f75e9',
    '--header-bg-img': `url("${blueUrl}")`,
    '--header-bg-img-top': `url("${blueTopUrl}")`,
    '--header-bg-img-bottom': `url("${blueBottomUrl}")`
  },

  red: {
    '--kr-color-primary': '#F26447',
    '--header-bg-img': `url("${redUrl}")`,
    '--header-bg-img-top': `url("${redTopUrl}")`,
    '--header-bg-img-bottom': `url("${redBottomUrl}")`
  },
  golden: {
    '--kr-color-primary': '#F5A24D',
    '--header-bg-img': `url("${goldenUrl}")`,
    '--header-bg-img-top': `url("${goldenTopUrl}")`,
    '--header-bg-img-bottom': `url("${goldenBottomUrl}")`
  }
}

```

重点：项目中开发者可通过DEFAULT_PRIMARY_TYPE进行设置默认主题；

系统中也内置了更改主题的功能，用户可根据喜好选择主题；

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732705612869-f177bdb4-1a53-45c4-b440-5e68a5bd8e30.png)

#### APP_CODE 应用code(重点)
+ 重点：这里的应用code应根据业务系统在开发平台中注册的应用中保存的编码设置
+ 后续需要请求的应用菜单，应用的多语言等都需要该code

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732705871946-6813c280-49e8-46ec-a36a-ff20ed2e3b1c.png)

#### HOME_URL 首页地址
模板项目中：如果设置的该首页地址在路由中存在则认为是首页地址否则会找到路由中的第一个有效路径作为路由地址，见src/utils/index.ts中获取首页地址逻辑代码如下：

```typescript
import router from '@/router'
import { HOME_URL } from '@/config'
/**
 *
 * @param routers 路由列表
 * @returns 默认首页
 */
export function getHomeUrl(): string {
  const routers = router.getRoutes()
  let defaultHomePath
  routers.forEach((item: any) => {
    if (item.path === HOME_URL || item.isHomeUrl) {
      defaultHomePath = item.path
    }
  })
  return defaultHomePath || routers[0].path
}
```

在用到首页地址的地方都会调用该方法，如果需要修改逻辑请全局搜索getHomeUrl即可找到使用首页地址的地方。

重点：所以建议在配置应用菜单时配置好首页地址，并在src/config.ts中赋值给HOME_URL

### 系统服务地址配置（重点）
+ 为了能够在部署时灵活修改后端接口地址，该项目模板将前端所需要连接的所有地址都统一配置在了public/config.js中，可根据业务需求进行相应接口地址调整代码如下：

```javascript
// eslint-disable-next-line no-unused-vars
window.serviceConfig = {
  // 开发环境配置
  development: {
    // 本地环境接口地址
    // 后端访问地址的根路径，在vue.config.js中配置devServer，设置服务路径的路由规则，如果是分布式，则分别设置每个服务路径的路由规则
    VITE_API_URL: '',
    // WebSocket、在线文档等
    VITE_ONLINE_URL: '/api/ws',

    // 字体文件地址
    VITE_API_FONT_URL: 'http://10.11.228.190/font',
    // 云程前端项目运行的地址
    VITE_API_YUNCHENG_URL: `http://${location.hostname}:3000`
  },
  //  打包之后的测试环境配置
  test: {
    // 接口地址
    VITE_API_URL: '',

    // WebSocket、在线文档等
    VITE_ONLINE_URL: '/api/ws',
    // 字体文件地址
    VITE_API_FONT_URL: 'http://10.11.228.190/font',
    // 云程前端项目运行的地址
    VITE_API_YUNCHENG_URL: `http://${location.hostname}:3000`
  },
  // 打包之后的生产环境配置
  production: {
    // 接口地址
    VITE_API_URL: 'http://10.11.228.190',

    // WebSocket、在线文档等
    VITE_ONLINE_URL: 'http://10.11.228.190/api/ws',

    // 字体文件地址
    VITE_API_FONT_URL: 'http://10.11.228.190/font',
    // 云程前端项目运行的地址
    VITE_API_YUNCHENG_URL: 'http://10.11.228.190/yc'
  }
}

```

+ 在src/api/config/service-port.ts根据后端做的服务前缀代理进行相关的服务前缀配置；
+ 然后在src/api/modules下建相应模块接口文件进行相应接口地址拼接；可参src/api/modules/common/login.ts

```javascript
// 后端微服务模块前缀

/**
 * 应用的服务前缀
 */
export const PORT_SYSTEM = '/api/api'


```

```javascript
import { PORT_SYSTEM } from '@/api/config/service-port'
import http from '@/api'

/**
 * @name 登录模块
 */
// 登录模块
export namespace Login {
  export interface ReqLoginForm {
    userName: string
    password: string
  }
  export interface ResLogin {
    token: string
    userInfo: {
      staffId: number
      [key: string]: any
    }
  }
  export interface ResAuthButtons {
    [key: string]: string[]
  }

  // 获取验证码类型返回类型
  export interface Captcha {
    [key: string]: string[]
  }

  // 校验验证码入参
  export interface CheckCaptcaReq {
    captchaType: string // 验证码类型，暂时只有一种,为 captchaType:blockPuzzle
    pointJson: string // 拖动的点位信息(有加密)
    token: string // token信息(验证码token)
  }

  // 校验验证码出参
  export interface CheckCaptcaRes {
    [key: string]: string[]
  }

  export interface AuthInfo {
    permissions: string[]
    roles: string[]
    menus: AppCustomRouteRecordRaw[]
  }
  export interface ReqGetParams {
    name?: string
    ecode?: string
    namespace?: string
    [property: string]: any
  }
  export interface AuthUser {
    appCode: string
    fetchAvatar: boolean // 是否有头像
  }
}
// 获取验证码
export const getCaptcha = (params: { captchaType: string }) => {
  return http.post<Login.Captcha>(PORT_SYSTEM + `/captcha/get`, params, { loading: false })
}

// 获取验证码
export const checkCaptcha = (params: Login.CheckCaptcaReq) => {
  return http.post<Login.CheckCaptcaRes>(PORT_SYSTEM + `/captcha/check`, params, { loading: false })
}

// 用户登录
export const authLogin = (params: Login.ReqLoginForm) => {
  return http.post<Login.ResLogin>(PORT_SYSTEM + `/user/auth/login`, params, { loading: false })
}

// 获取用户信息和权限信息
export const getAutInfoApi = (params: Login.AuthUser) => {
  return http.post(PORT_SYSTEM + `/client/user-auth-info`, params)
  // return authInfo
}
// 用户退出登录
export const logoutApi = () => {
  return http.post(PORT_SYSTEM + `/logout`)
}

```

## 全局样式
```bash
styles                 
├─ koron               
│  └─ var.scss         
├─ tailwind            
│  ├─ base.scss        
│  ├─ components.scss  
│  └─ utilities.scss   
├─ theme               
│  ├─ aside.ts         
│  ├─ header.ts        
│  ├─ menu.ts          
│  └─ primary-type.ts  
├─ common.scss         
└─ index.scss          

```

+ koron文件夹:可以对koron-ui组件库进行主题自定义设置--若产品风格不变，这里无需改动；
+ tailwind文件夹：对tailwind css框架中基础样式的引用--这里无需改动
+ theme文件夹:是对项目的头部导航，侧边栏，菜单的**黑暗模式**和**正常模式**的**颜色变量设置**以及对**三种主题类型**的颜色变量设置；如果需要**自定义更多主题色或更改主题色**可在此处修改。
+ common.scss: 项目全局样式
    1. 定义了页面加载进度条`<font style="color:#ED740C;">nprogress</font>`的样式--若产品风格不变，`<font style="color:#ED740C;">nprogress</font>`的样式无需改动
    2. 定义了**占满容器剩余部分**的class`<font style="color:#ED740C;">flex-full</font>`以及其衍生类，需要定义**占满容器剩余部分**的元素可直接使用该class** **。



重点：

+ 建议开发过程中尽量使用已定义好的[样式变量](http://10.11.3.132:8082/platform/ebs_ui/blob/master/packages/theme-chalk/src/element/var.scss)自动生成的csss变量而非实际样式值：比如使用主题色，使用常用字体大小，字体颜色等等。
+ 其中[样式变量](http://10.11.3.132:8082/platform/ebs_ui/blob/master/packages/theme-chalk/src/element/var.scss)中的scss变量是根据elementPlus的定制的主题能够自动生成css变量，我们只需要使用ElementPlus的css变量即可，如主题色var(--el-color-primary)

## 字体图标使用
本项目模板中在main.ts分别引入了基础图标和菜单图标如下：

```typescript
// iconfont
/** 公司的通用基础icon图标
 * 图标库地址: https://www.iconfont.cn/manage/index?spm=a313x.manage_index.i1.db775f1f3.53683a81TEUz0d&manage_type=myprojects&projectId=4651197
 * 说明： 不引入也可通过组件库中kr-svg-icon组件使用
 *  */
import '@/assets/iconfonts/common/iconfont.js'
/** 公司的菜单图标
 * 图标库地址: https://www.iconfont.cn/manage/index?spm=a313x.manage_index.i1.db775f1f3.53683a81TEUz0d&manage_type=myprojects&projectId=4616214
 * 说明：每个系统要用的菜单图标库要与菜单配置系统（应用开发平台）为菜单配置的图标保持一致
 *  */
import '@/assets/iconfonts/menu/iconfont.js'


```

使用方法：

1. 引入基础图标和菜单图标文件
2. 使用kr-svg-icon组件（组件教程见[koron-ui组件库文档](http://10.11.228.190:8889)）

注意：各项目要与应用开发平台及时沟通进行同步图标文件（后续可部署图标为在线模式（需要有个静态资源服务地址，类似思源字体部署方式），引入图标文件链接地址就可同步了）



## 布局（一般无需改动）
该框架的总体布局和公共功能无特殊需求一般不用改动，如果因为接口数据结构或逻辑的调整可参考以下各个部分的介绍帮助开发者快速理解开发逻辑从而能够提高相应的开发效率。

### <font style="color:rgb(0, 0, 0);">顶部导航的介绍</font>
![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733298160387-0d0220ed-6b4c-4f37-8828-f4d99fa23571.png)

#### <font style="color:rgb(0, 0, 0);">title</font>
系统名称，在本项目中是通过`src/layouts/components/Header/components/Title.vue`组件渲染的

通过**请求应用列表**和本地配置的**APP_CODE**过滤出该应用对象获得title.

核心代码如下：

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733283076617-1f53947e-d9c6-480a-b215-bcdd47d8938e.png)

重点：若需要修改title相关逻辑可根据上述介绍在相关代码位置进行逻辑修改。

#### <font style="color:rgb(0, 0, 0);">logo</font>
系统logo，在本项目中是在`src/layouts/layoutClassic/index.vue`渲染logo图片实现的。

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733284933418-9455f683-ceed-4f01-9c7c-e96d5448c115.png)

重点：其中logo图片地址：`@/assets/images/logo.png`，如需要修改，替换掉图片即可

#### <font style="color:rgb(0, 0, 0);">导航右侧：</font>
在本项目中是通过`src/layouts/components/Header/ToolBarRight.vue`组件渲染的

由用户名称，消息提示，设置三部分组成

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733293738508-ecd8ae8d-a7e2-4989-b732-7636af061766.png)

##### <font style="color:rgb(0, 0, 0);">用户名称显示</font>
 通过状态管理器中userStore的数据获取：`userStore.loginUserInfo?.realName`

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733293765965-2136ac80-43f4-4869-bb80-b1a798eac5c8.png)

##### <font style="color:rgb(0, 0, 0);">消息提示</font>
在本项目中是通过`src/layouts/components/Header/components/Message.vue`组件渲染的，相关消息的请求接口（src/api/modules/commonmessage-list）在此处调用,如需修改相关消息的逻辑可在此处进行开发。

##### <font style="color:rgb(0, 0, 0);">设置图标中更多功能(这里是)</font>
<font style="color:rgb(0, 0, 0);">在本项目中是通过</font>`<font style="color:rgb(0, 0, 0);">src/layouts/components/Header/components/Setting.vue</font>`<font style="color:rgb(0, 0, 0);">组件渲染的</font>

<font style="color:rgb(0, 0, 0);">其中包含了个人信息，修改密码，设置皮肤，设置语言，设置字体，退出登录等功能，详见相关组件即可</font>

### <font style="color:rgb(0, 0, 0);">菜单布局的介绍</font>
![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733298195255-d6489460-71fe-4c5c-8bbd-8246570a9377.png)

菜单的渲染在`src/layouts/layoutClassic/index.vue`中开发：

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733295183115-6e67633c-9efa-42e0-bf3e-c52cc467d3b9.png)

菜单数据是menuList是根据状态管理器authStore的showMenuListGet获取的

### <font style="color:rgb(0, 0, 0);">tab页签的介绍</font>
![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733298245476-83cdfa17-d45b-45f7-8cbb-976385b5d93f.png)

该功能用于方便用户快速打开已打开的页面

在本项目中是通过`src/layouts/components/Tabs`组件渲染的

页签的显示关闭通过状态管理器`src/stores/modules/tabs.ts`进行逻辑处理的



# 第三部分:基础功能使用
## 公共组件
已在main.ts中进行全局注册，可直接使用。

### <font style="color:rgb(0, 0, 0);">左右布局组件TwoColPage</font>
固定左侧容器宽度，右侧容器占满剩余空间

源码位置：`src/components/TwoColPage`

使用时左右两部分分别通过具名插槽right和left渲染进去

```vue
<template>
  <TwoColPage>
    <template #left>
      <div></div>
    </template>
    <template #right>
      <div></div>
    </template>
  </TwoColPage>
</template>
```

<font style="color:rgb(44, 62, 80);">代码演示参考 应用开发平台》组织管理》组织结构（src/views/organization/organization-item/index.vue)</font>

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733299653405-9bb7e1fe-0a4f-4c45-9dfe-8bbb58ea99a5.png)

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733912774459-a636d7e7-0de7-4a28-86dc-e1d668f354bc.png)

:::info
统一的布局组件帮助系统能够布局保持一致，维护更方便

:::

### 选人组件UserSelect
作为表单控件，点击该控件，弹出左组织右用户的选人弹窗.

注意：该组件属于业务组件：在该组件内是请求了组织，人员等接口，数据字段是确定的，所以在为modelValue赋值时注意要求的数据类型

源码位置：`src/components/UserSelect`

可通过multiple属性配置多选 还是单选；通过default-value 为控件初始化所选人员，通过change事件获得已选人员

该组件属性及事件说明如下：

属性

| 属性名 | 说明 | 类型 | 默认值 |
| --- | --- | --- | --- |
| default-value  | 初始化已选数据(必传) | `SelStaff`[] | [] |
| multiple | 是否多选 | boolean | true |


事件

| 事件名 | 说明 | Type |
| --- | --- | --- |
| change | 当点击确定按钮触发的事件 | Function:(ids:string[],selectedData:`User.Staff`[] ) => void |


其中`SelStaff`结构中的staffId必须传递：

```typescript
interface SelStaff {
  staffId: number // 员工ID
  [property: string]: any
}
```

`User.Staff ` 来源于 'src/api/modules/common/user',数据结构如下：

```vue
interface Staff {
    /**
     * 账号状态(1正常；2冻结)
     */
    accountStatus: AccountStatus
    /**
     * 应用code
     */
    appCode?: string
    /**
     * 头像
     */
    avatar?: string
    /**
     * 生日
     */
    birthday?: Date
    /**
     * 直接上级
     */
    directSupervisor?: string
    /**
     * 岗位编码
     */
    dutyCode?: number
    /**
     * 邮箱
     */
    email: string
    /**
     * 英文名
     */
    englishName?: string
    /**
     * 性别(1男；2女；)
     */
    gender: Gender
    /**
     * 是否实体用户
     */
    isEntityUser: boolean
    /**
     * 手机号
     */
    mobile: string
    /**
     * 组织Node名称
     */
    orgNodeName?: string
    /**
     * 职务编码
     */
    positionCode?: number
    /**
     * 姓名
     */
    realName: string
    /**
     * 员工ID
     */
    staffId: number
    /**
     * 员工状态(1在职；2离职；3休假)
     */
    staffStatus: StaffStatus
    /**
     * 更新时间，系统自动赋值
     */
    updateTime?: Date
    /**
     * 更新人，系统自动赋值用户账号
     */
    updateUser?: string
    /**
     * 用户登录名
     */
    username: string
    /**
     * 工号
     */
    workNo: string
    [property: string]: any
  }
```

示例代码如下：

```vue
<template>
   <UserSelect
    :default-value="selectUser"
    :multiple="false"
    @change="userSelChange"
  ></UserSelect>
</template>
<script setup lang="ts" name="TrustFormDialog">
import { ref, reactive } from 'vue'
import type { User } from '@/api/modules/common/user'
import UserSelect from '@/components/UserSelect/index.vue'

const model = ref<{ [key: string]: any }>({})

// 选中的人
const selectUser = ref<
  {
    staffId: number // 员工ID
    [property: string]: any
  }[]
>([])

const userSelChange = (ids: (string | number)[], data: User.Staff[]) => {
  const selectedObj = data[0]
  model.value.delegateId = ids.join(',')
  model.value.delegateName = selectedObj.realName
  model.value.delegateDeptId = selectedObj.orgNodeId
  model.value.delegateDeptName = selectedObj.orgNodeName
  model.value.delegate = model.value.delegateName ? model.value.delegateName + '/' + model.value.delegateDeptName : null
}

</script>
```

<font style="color:rgb(44, 62, 80);">代码演示参考 应用开发平台》流程中心》我的委托》我给他人的委托》新增（src/views/workflow/modules/trust-task/FormDialog.vue)</font>

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733305530401-270f4eda-02c1-45b0-a1ea-be43e2de046c.png)

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733305541132-295f991c-bf45-41d2-92b0-ced9c63780af.png)

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733305419494-a38c4368-ab13-4408-99be-ad7225d85376.png)

## 国际化
本项目中国际化分为静态数据多语言配置和动态数据多语言配置

本项目基于vue-i18n实现国际化的，实现的基本思路如下：

### <font style="color:rgb(25, 27, 31);"> 定义语言包：</font>
<font style="color:rgb(25, 27, 31);">需要几种语言展示，就定义几个语言包,本项目模板中只定义了三种语言，</font>

:::info
**<font style="color:rgb(25, 27, 31);">如果需要配置其他语言，可在</font>**<font style="color:rgb(25, 27, 31);">languages/modules下</font>**<font style="color:rgb(25, 27, 31);">增加相应语言包。</font>**

:::

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732869676907-8b2ab086-0808-41be-87b3-c905440c67b2.png)

### **<font style="color:rgb(25, 27, 31);">创建对象，对语言包进行整合</font>**
<font style="color:rgb(25, 27, 31);">对象的 key 为语言包的引用，值为语言包对象</font>

<font style="color:rgb(25, 27, 31);">在项目中创建语言包文件夹languages/modules中存放需要的语言包ts文件，例如创建zh-hans.ts,zh-hant.ts和en-us.ts三个语言，每种语言包中键名是自定义的，后面会在组件中使用。例如语言包部分配置如下：</font>

```typescript
export default {
  header: {
    personalData: '个人信息',
    changePassword: '修改密码',
    theme: '设置皮肤',
    themeConfig: {},
    language: '设置语言',
    fontSizeConfig: '设置字体',
    version: '版本',
    logout: '退出登录',
    system: '后台管理系统',
    def: '默认'
  }
} 
```

```typescript
export default{
  header: {
    personalData: 'Profile',
    changePassword: 'Change Password',
    theme: 'Look And Feel',
    language: 'Language',
    fontSizeConfig: 'Font Size',
    version: 'Version',
    logout: 'Log Out',
    system: 'BackGround Manage System'
  }
}
```

:::info
**<font style="color:rgb(25, 27, 31);">重点：如果需要配置其他系统内的静态文字，可在各个语言包中增加相应键值。</font>**

:::

#### 静态多语言配置
静态多语言配置在前端项目本地配置:系统内静态文字

在src/languages/modules各个语言包内配置

1. 布局头部各个功能的文字显示

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732874107526-68b4cbdf-10f6-4059-961f-5020c805ae1d.png)

2. http错误码的提示信息和错误页面的文字

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732874462837-197265fd-2416-4b15-a0dd-f0ef3e93c94b.png)

3. 登录模块的文字信息

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732874498807-61fcd47f-89a7-45a7-a1a5-a6305ef418c4.png)

4. 流程相关的文字显示

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1732874521784-8c0d26b0-ddc9-49ed-bfee-b3d26d6eac34.png)

#### 动态多语言配置
动态数据多语言通过接口请求获得

一般各个模块的表格字段，表单字段等都是通过在**应用开发平台**配置词条，然后再在项目中加载获取的。

:::info
重点：需要配置语言和语言词条请通过**应用开发平台**配置。

:::

实现原理（可不看）：

在路由拦截处通过状态管理器中src/stores/modules/language.ts中的isSetLanguage判断是否已加载过词条

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733124886761-6f1cd373-49a7-4083-84d3-4b3c9f6e9704.png)

若未加载就会通过状态管理器中的setLanguageList方法进行请求该应用的语言种类和各语言种类对应的词条，各类语言请求的词条分别与本地语言包进行对比：相同key值的，请求的数据会覆盖掉本地语言包中相应的值。

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733127904828-cb819a6e-fcf2-4f61-ac6f-5fd796fa037b.png)

### <font style="color:rgb(25, 27, 31);">引入语言包</font>
#### 引入本地语言包 (可不看)
实现原理（可不看）：

在src/languages/index.ts引入本地语言包，并创建i18n实例抛出。

```typescript
import { createI18n } from 'vue-i18n'
import { getBrowserLang } from '@/utils'

// 定义一个通用的嵌套对象类型
interface NestedObject {
  [key: string]: any // 所有属性可以是任意类型
}

// 引入目录下文件
const modules = import.meta.glob('./modules/*', { eager: true })
/**
 * 获取所有本地语言文件
 * @param {Object} mList
 */
function getLangFiles(mList: NestedObject): NestedObject {
  const msg: NestedObject = {}
  for (const path in mList) {
    if (mList[path].default) {
      const pathName = path.slice(path.lastIndexOf('/') + 1, path.length - 3) //  获取文件名
      if (msg[pathName]) {
        msg[pathName] = {
          ...mList[pathName],
          ...mList[path].default
        }
      } else {
        msg[pathName] = mList[path].default
      }
    }
  }
  return msg
}
export const message = getLangFiles(modules) // 获取所有本地语言文件

// 创建i8实例
const i18n = createI18n({
  allowComposition: true,
  legacy: false,
  locale: getBrowserLang(),
  messages: message
})

export default i18n


```

#### 引入动态数据语言包(可不看)
实现原理（可不看）：

在src/stores/modules/language.ts中引入i18n实例，并在获取到动态数据语言包后进行语言包配置：

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733132664579-6c301858-a221-44a7-b7b6-f38305702f14.png)

#### 引入第三方语言包
如果需要引入其他第三方语言包可按照下方实现方式引入：

在本项目App.vue中需要引入elementPlus语言包和koronUi语言包

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733133244143-115cdec7-d3fc-4293-a762-ad17d6fc1648.png)

本项目中也做了动态切换语言的功能：

src/layouts/components/Header/components/Language.vue

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733133389050-7daaeb89-fb1f-47c9-b072-922d43fb395c.png)

src/App.vue

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733133333626-0af6ca94-68a3-4b7d-871d-184a58a9c21d.png)

### <font style="color:rgb(25, 27, 31);">挂载对象</font>
实现原理（可不看）：

<font style="color:rgb(25, 27, 31);">在项目的主入口文件中挂载i18n对象，例如main.ts中：</font>

```typescript
// vue i18n
import I18n from '@/languages/index'
// App.vue
import App from './App.vue'
const app = createApp(App)
app.use(I18n)
```

### 使用（重点）
#### **<font style="color:rgb(25, 27, 31);">在模板中使用</font>**
参考：src/views/login/components/ResetPassword.vue

```html
<el-input
  :placeholder="$t('login.resetPassword.smsPlaceholder')"
  clearable
>
  <template #suffix>
    <el-button
      type="primary"
      class="w-full code"
      >{{ $t('login.resetPassword.getSmsCode') }}</el-button
    >
  </template>
</el-input>
```

#### 在vue文件中script中使用
参考：src/views/login/components/ResetPassword.vue

```html
<script setup lang="ts">
  import { ElMessageBox, ElMessage } from 'element-plus'
  import { useI18n } from 'vue-i18n'
  const { t } = useI18n()
  const logout = () => {
    ElMessageBox.confirm(t('common.loginOutMessage'), t('common.reminder'), {
      confirmButtonText: t('common.ok'),
      cancelButtonText: t('common.cancel'),
      type: 'warning'
    }).then(async () => {
      ElMessage.success(t('common.ok'))
    })
  }
</script>
```

#### 在普通ts或js文件中使用：
参考：src/api/helper/check-status.ts

在文件中引入I18n实例,然后使用实例的global对象中的t方法

```typescript
import { ElMessage } from 'element-plus'
import I18n from '@/languages/index'
const { t } = I18n.global as any
ElMessage.error(t('error.400'))
```

## 路由、菜单
路由配置在 [src/routers](https://github.com/HalseySpicy/Geeker-Admin/tree/master/src/routers) 文件下面：

:::info
+ 项目默认采用动态添加路由方式控制
+ 需要其它路由功能根据自己项目需求改造

:::

### 目录结构
```plain
.
├─ routers                    # 路由相关文件
├ ├─ modules                  # 路由模块
├ ├ ├─ dynamicRouter.ts       # 动态路由添加逻辑
├ │ └─ staticRouter.ts        # 静态路由配置
├ └─index.ts                  # 封装后的路由拦截
└─
```

### 路由参数
```typescript
/** 路由参数简介 */
interface RouteRecordRaw {
    /** 路由访问路径 */
    path: string;
    /** 路由 name */
    name: string;
    /** 路由重定向地址 */
    redirect?: string;
    /** 视图文件路径 */
    component: string | (() => Promise<unknown>);
    /** 路由元信息 */
    meta: {
       /**外链地址 */
        url?:string;
        /** 菜单和面包屑对应的图标 */
        icon: string;
      
        /** 路由标题 (用作 document.title || 菜单的名称) */
        title: string;
      
        /** 是否在菜单中隐藏 (通常列表详情页需要隐藏) */
        hide: boolean;

        /** 当前路由是否缓存 */
        isKeepAlive: boolean;
        /** 菜单是否固定在标签页中 (首页通常是固定项) */
        isAffix:boolean;
       /** 菜单是否全屏 (示例：数据大屏页面) */
        isFull: boolean;
        /** 菜单是否内嵌在layout下 */
        isInner:boolean;
        /** 外链菜单在新页签中打开 */
        isOut:boolean;
    };
    /** 多级路由嵌套 */
    children: RouteRecordRaw[];
}
```

:::warning
+ 当path以"http://"或"https://"开头时认为是外链；
+ 菜单打开方式：内嵌，全屏，新页签，三个方式是互斥的。
+ 新页签方式在path配置的是外链时起作用，否则当作内嵌菜单处理；内嵌，全屏无论path是普通菜单路径还是外链都起作用；

:::

### 路由实现
+ 默认根据后端接口返回的数据生成动态路由,在utils/router-helper.ts中的generateRoute方法对原始后端数据进行处理返回RouteRecordRaw接口对应结构的路由数据

```typescript
// 处理树结构的原始数据为路由需要的
export function generateRoute(data: any[], parentPath: string, parentStatus: boolean, arr: any[]) {
  data.forEach((item, index) => {
    if (item.style === 3) {
      return
    }
    arr.push({
      path: `${parentPath}/${item.path}`,
      name: `${item.interfaceItemId}`,
      meta: {
        icon: item.icon,
        title: item.name,
        hide: item.hide,
        isKeepAlive: item.keepAlive,
        isAffix: false,
        isFull: item.openMode === '2',
        isInner: item.openMode === '1',
        isOut: item.openMode === '3'
      },

      children: []
    })

    if (isHttp(item.path)) {
      arr[index].meta.url = item.path
      // 外链的菜单：无组件，无子菜单
      arr[index].component = ''
      arr[index].name = `${parentPath.replace(/\//g, '_').substring(1)}_${item.interfaceItemId}`
      delete arr[index].children
      if (item.openMode === '1' || item.openMode === '2') {
        arr[index].path = `${parentPath}/${item.interfaceItemId}`
        arr[index].component = InnerLink
      } else {
        arr[index].path = item.path
      }
    } else {
      // 菜单类型的：
      if (item.component && typeof item.component === 'string') {
        // 配置的组件路径不存在时，会赋值为undefined
        arr[index].component = modules['/src/views' + item.component + '.vue']
      }
      if (item.children && item.children.length > 0) {
        const list = item.children
        arr[index].redirect = `${parentPath}/${item.path}/${list[0].path}`
        generateRoute(item.children, `${parentPath}/${item.path}`, parentStatus && item.status, arr[index].children)
      } else {
        delete arr[index].children
      }
    }
  })
  return arr
}
```



+ 如果想把路由变成本地，直接更改 [src/api/modules/common/login.ts => getAutInfoApi](http://10.11.3.132:8082/platform/ebs_vue3_template/blob/master/src/api/modules/common/login.ts) 方法

```typescript
import authInfo from "@/assets/json/auth-info.json";

// 获取权限信息
export const getAuthUserApi = (params: Login.AuthUser) => {
  //return http.post(PORT_SYSTEM + `/client/user-auth-info`, params)
  // 如果想让菜单变为本地数据，注释上一行代码，并引入本地 authMenuList.json 数据
  return authInfo
}
```

### 生成的路由结果
#### 一级路由
```typescript
const home = {
    "path": "/admin_portal/home",
    "name": "Home",
    "meta": {
        "icon": "anli",
        "parentIcon": "anli",
        "title": "首页",
        "hide": false,
        "alwaysShow": false,
        "isKeepAlive": false,
        "isFull": false,
        "isAffix": false,
        "isInner": true,
        "isOut": false
    }
};
```

#### 二级路由
```typescript
const application = {
    "path": "/admin_portal/applyfolder",
    "name": "Applyfolder",
    "redirect": "/admin_portal/applyfolder/application"
    "meta": {
        "icon": "",
        "parentIcon": "",
        "title": "应用管理",
        "hide": false,
        "alwaysShow": false,
        "isKeepAlive": false,
        "isFull": false,
        "isAffix": false,
        "isInner": true,
        "isOut": false
    },
    "children": [
        {
            "path": "/admin_portal/applyfolder/application",
            "name": "Application",
            "meta": {
                "icon": "yingyongzhuce",
                "parentIcon": "yingyongzhuce",
                "title": "应用管理",
                "hide": false,
                "alwaysShow": false,
                "isKeepAlive": false,
                "isFull": false,
                "isAffix": false,
                "isInner": true,
                "isOut": false
            }
        },
        {
            "path": "/admin_portal/applyfolder/application/permission",
            "name": "Application/permission",
            "meta": {
                "icon": "zhuceyouli",
                "parentIcon": "zhuceyouli",
                "title": "权限项管理",
                "hide": false,
                "alwaysShow": false,
                "isKeepAlive": false,
                "isFull": false,
                "isAffix": false,
                "isInner": true,
                "isOut": false
            }
        }
    ],
    
};
```

### 菜单
+ 根据后台返回的菜单数据转换而来
+ 所以只要更改后台数据菜单会随之改变，整个项目只需维护一套数据即可

:::info
+ 菜单展示时需要过滤掉 hide 属性为 true 的路由

:::

+ utils/router-helper.ts：

```typescript
/**
 * @description 使用递归过滤出需要渲染在左侧菜单的列表 (需剔除 hide == true 的菜单)
 * @param {Array} menuList 菜单列表
 * @returns {Array}
 * */
export function getShowMenuList(menuList: AppRouteRecordRaw[]) {
  const newMenuList: AppRouteRecordRaw[] = JSON.parse(JSON.stringify(menuList))
  return newMenuList.filter((item) => {
    item.children?.length && (item.children = getShowMenuList(item.children))
    return !item.meta?.hide
  })
}
```

## 权限管理
### 权限的配置
在**应用开发平台**进行菜单配置，按钮配置，然后在权限管理处进行为角色配置权限菜单和权限按钮

#### 权限项配置
主要是为功能按钮配置权限标识，以便后续进行权限配置，前端开发者也应与后端开发者协商好对应的权限标识在此配置，以便后续权限按钮的使用。

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733280709573-6945067d-1b60-415c-95ab-5726cfc04033.png)

#### 菜单配置
![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733195937673-5357cf17-863f-4a3c-a832-26ff81db5c6e.png)

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733196439856-24345508-b540-425a-aff8-d4990ffb1657.png)

菜单的配置分为3类：目录，菜单，按钮，分别需要配置的属性不尽相同

目录：

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733214319388-f1d97011-971e-4489-82ee-79ae7f3135b0.png)

菜单：

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733214332309-3d630dfd-5403-473f-bac2-50821e24d4e3.png)

按钮配置：

![](https://cdn.nlark.com/yuque/0/2024/png/38559051/1733214297551-c836348c-a40d-419f-a4ae-0c1f4b905038.png)

具体配置规则见下方**权限的使用**字段对照关系处

### 权限的使用
#### 菜单权限的使用
在平台处配置的相关属性通过请求接口（ [src/api/modules/common/login.ts => getAuthUserApi](http://10.11.3.132:8082/platform/ebs_vue3_template/blob/master/src/api/modules/common/login.ts) 方法）获取当前用户的权限菜单，然后通过utils/router-helper.ts中的generateRoute方法对原始后端数据进行处理返回RouteRecordRaw接口对应结构的路由数据，具体字段对照关系如下（也是**<font style="color:#FFFFFF;background-color:#DF2A3F;">目录菜单按钮的配置规则</font>**）：

1. **菜单名称**(name):  对应路由的meta中的title字段
2. **页面打开方式**(openMode):
+ 值为1是**内嵌** 对应路由的meta.isInner为true,
+ 值为2是**全屏** 对应路由的meta.isFull为true,
+ 值为3是**新页签** 对应路由的meta.isOut为true,

:::warning
+ 当path以"http://"或"https://"开头时认为是外链；
+ 菜单打开方式：内嵌，全屏，新页签，三个方式是互斥的。
+ 新页签方式在path配置的是外链时起作用，否则当作内嵌菜单处理；内嵌，全屏无论path是普通菜单路径还是外链都起作用；

:::

3. **页面路由**(path)：相当于是当前节点的标识，当配置的不是外链时对应的路由path是由**父节点路由path**+**'/'**+**当前节点的path**组成，所以实质上是用来作为对应路由的path的末尾的一个拼接字符串。

:::info
在配置该属性注意是一串英文字符串或数字或英文字符串和数字组合，前面不能带'/'，例如：myFirstMenu

:::

4. **对应的vue组件(component)**:组件相对路径，用于配置路由的视图文件路径

:::info
在配置该属性时：例如组件是 src/views/demo/DemoViewList.vue，则该属性只需输入 /demo/DemoViewList

:::

5. **关联权限：**为权限配置做准备
6. **图标(icon)**：对应路由的meta.icon用于渲染菜单时渲染配置的菜单图标
7. **启用路由缓存(keepAlive)**:只有菜单类型有该属性，对应路由的meta.isKeepAlive
8. **隐藏(hide)**：只有菜单类型有该属性，对应路由的meta.hide



在页面中未展示出的属性还有：

路由的name用来标识路由的唯一性的这里用后端返回来的interfaceItemId表示

路由的meta.url：如果path配置的是外链，则会为路由的meta元信息中配置url属性用来存该外链值，用于内嵌方式和全屏方式路由跳转时，iframe获取当前路由的外链地址；打开新页签方式时，点击菜单以链接的方式跳转而不是路由跳转。

```typescript
// 处理树结构的原始数据为路由需要的
export function generateRoute(data: any[], parentPath: string, parentStatus: boolean, arr: any[]) {
  data.forEach((item, index) => {
    if (item.style === 3) {
      return
    }
    arr.push({
      path: `${parentPath}/${item.path}`,
      name: `${item.interfaceItemId}`,
      meta: {
        icon: item.icon,
        title: item.name,
        hide: item.hide,
        isKeepAlive: item.keepAlive,
        isAffix: false,
        isFull: item.openMode === '2',
        isInner: item.openMode === '1',
        isOut: item.openMode === '3'
      },

      children: []
    })

    if (isHttp(item.path)) {
      arr[index].meta.url = item.path
      // 外链的菜单：无组件，无子菜单
      arr[index].component = ''
      arr[index].name = `${parentPath.replace(/\//g, '_').substring(1)}_${item.interfaceItemId}`
      delete arr[index].children
      if (item.openMode === '1' || item.openMode === '2') {
        arr[index].path = `${parentPath}/${item.interfaceItemId}`
        arr[index].component = InnerLink
      } else {
        arr[index].path = item.path
      }
    } else {
      // 菜单类型的：
      if (item.component && typeof item.component === 'string') {
        // 配置的组件路径不存在时，会赋值为undefined
        arr[index].component = modules['/src/views' + item.component + '.vue']
      }
      if (item.children && item.children.length > 0) {
        const list = item.children
        arr[index].redirect = `${parentPath}/${item.path}/${list[0].path}`
        generateRoute(item.children, `${parentPath}/${item.path}`, parentStatus && item.status, arr[index].children)
      } else {
        delete arr[index].children
      }
    }
  })
  return arr
}
```

#### 按钮权限的使用
1.  通过请求接口（ [src/api/modules/common/login.ts => getAutInfoApi](http://10.11.3.132:8082/platform/ebs_vue3_template/blob/master/src/api/modules/common/login.ts) 方法）当前用户的权限按钮，并存在stores/modules/auth.ts中定义的authButtonList，
2. 通过在src/directives/modules/auth.ts中定义的v-auth指令确定是否展示页面中的功能按钮；

:::info
具体使用只需要在vue文件中使用该指令，并为该指令传入该按钮的权限标识即可：

:::

例如：用户管理模块，对”新建“按钮进行权限设置,其中‘user:staff:save’为用户新增修改的权限标识

```html
<el-button
  v-auth="'user:staff:save'"
  type="primary"
>
 </el-button>
```

## 网络请求
+ 项目封装了`Axios`来做网络请求，包括请求 Loading、错误处理、取消请求等功能
+ 可以按照自己项目需求来进行封装

### 目录结构
```plain
├─ api                               网络请求文件夹                                 
│  ├─ config                         请求配置信息   
│  │  ├─ http-enum.ts                请求相关的枚举类型 
│  │  └─ service-port.ts             后端微服务模块前缀  
│  ├─ helper                         请求辅助工具  
│  │  ├─ axios-cancel.ts             拦截重复请求 
│  │  ├─ check-status.ts             对各个http错误码做的相关的反馈  
│  │  └─ service-loading.ts          全局请求loading配置
│  ├─ interface                      api接口的请求参数和返回数据的类型定义文件夹  
│  │  └─ index.ts                      
│  ├─ modules                        请求函数模块，强烈建议根据不同的模块创建不同的请求文件  
│  │  └─ common                      公共请求接口  
│  │     ├─ application.ts           应用列表  
│  │     ├─ dict.ts                  数据字典  
│  │     ├─ language-item.ts         语言词条  
│  │     ├─ language.ts              语言列表  
│  │     ├─ login.ts                 登录  
│  │     ├─ message-list.ts          消息列表  
│  │     └─ user.ts                  用户  
   └─ index.ts                       封装后的axios：请求拦截，响应拦截  
```



### 配置（重点）
> 不出意外的话，你应该要修改请求的`baseURL`。
>

在`index.ts`文件的 28 行你可以看到一个默认的基础配置

```typescript
const config = {
  // 默认地址请求地址，可在public/config.js 文件中修改各个环境下的请求地址
  baseURL: window.serviceConfig[import.meta.env.VITE_USER_NODE_ENV].VITE_API_URL as string,
  // 设置超时时间
  timeout: ResultEnum.TIMEOUT as number,
  // 跨域时候允许携带凭证
  withCredentials: true
}
```

你可以在此处修改或添加 axios 的基本配置。

:::info
重点：`baseURL`是通过环境变量加载的，可以通过项目根目录下的`public/config.js`文件中修改不同环境下的`VITE_API_URL`，而不是在此处直接修改。

:::

### 请求拦截
代码位置：`index.ts 58:108`

```typescript
/**
     * @description 请求拦截器
     * 客户端发送请求 -> [请求拦截器] -> 服务器
     * token校验(JWT) : 接受服务器返回的 token,存储到 vuex/pinia/本地储存当中
     */
    this.service.interceptors.request.use(
      (config: CustomAxiosRequestConfig) => {
        const userStore = useUserStore()
        // 重复请求不需要取消，在 api 服务中通过指定的第三个参数: { cancel: false } 来控制
        config.cancel ??= true
        config.cancel && axiosCanceler.addPending(config)
        // 当前请求不需要显示 loading，在 api 服务中通过指定的第三个参数: { loading: false } 来控制
        config.loading ??= true
        config.loading && showFullScreenLoading()

        // 是否需要设置 token
        let isToken = (config!.headers || {}).isToken === false
        whiteList.some((v) => {
          if (config.url && config.url.indexOf(v) > -1) {
            return (isToken = true)
          } else {
            return (isToken = false)
          }
        })
        if (config.headers && typeof config.headers.set === 'function' && !isToken) {
          config.headers.set('x-access-token', userStore.token)
          config.headers.set('Authorization', `Bearer ${userStore.token}`)
        }
        // 请求头携带Application:应用编码
        const appCode = useAuthStore().appCode
        config.headers.set('Application', appCode)
        // 请求头携带Lang：国际化语言种类
        config.headers.set('Lang', useGlobalStore().language as unknown as string)

        // 请求头携带Ignore-Translate：是否需要翻译
        const configUrl = config.url as unknown as string
        const isIgnoreTranslate = IgnoreTranslateList.some((item: string) => configUrl.startsWith(item))
        if (!isIgnoreTranslate) {
          config.headers.set('Ignore-Translate', false)
        } else {
          config.headers.set('Ignore-Translate', true)
        }

        if (config.method === 'get') {
          config.params = {
            _t: Date.parse(String(new Date())) / 1000,
            ...config.params
          }
        }
        return config
      },
      (error: AxiosError) => {
        console.log('requestError', error)
        return Promise.reject(error)
      }
    )
```

+ 在请求之前检查当前请求需不需要全局的 loading，
+ 在请求之前检查当前请求需不需要携带token,若需要则在 header 请求头中携带`x-access-token`和`Authorization`分别用于云程工作流请求接口和平台请求接口。token 名称不一定是`x-access-token`或`Authorization`，具体情况根据自己项目配置
+ 任何接口请求头header都需要携带`Application`、`Lang`、`Ignore-Translate`。

### 响应拦截
代码位置：`index.ts 114:166`

```typescript
this.service.interceptors.response.use(
  (response: AxiosResponse & { config: CustomAxiosRequestConfig }) => {
    const { data, config } = response
    if (!data) {
      // 返回“[HTTP]请求没有返回值”;
      throw new Error()
    }
    const userStore = useUserStore()
    axiosCanceler.removePending(config)
    config.loading && tryHideFullScreenLoading()
    // 登录失效
    if (data.code === ResultEnum.OVERDUE) {
      // 删除token,删除用户缓存
      userStore.loginOut()
      // 刷新页面重新走一次路由让它过router.beforeEach的校验
      const href = window.location.href
      window.location.href = href
      ElMessage.error(data.message)
      return Promise.reject(data)
    }
    // 全局错误信息拦截（防止下载文件的时候返回数据流，没有 code 直接报错）
    if (data.code && data.code !== ResultEnum.SUCCESS) {
      config.errMsg ??= true
      config.errMsg && ElMessage.error(data.message)
  
      return Promise.reject(data)
    }
  
    // 兼容云程的结果是result字段接收的，转成我们通用的data字段：
    renameKey(data, 'result', 'data')
    // 成功请求（在页面上除非特殊情况，否则不用处理失败逻辑）
    return data
  },
  async (error: AxiosError) => {
    console.log('responseError', error)
    const { response } = error
    tryHideFullScreenLoading()
    // 请求超时 && 网络错误单独判断，没有 response
    if (error.message.indexOf('timeout') !== -1) ElMessage.error(t('error.408'))
    if (error.message.indexOf('Network Error') !== -1) ElMessage.error(t('error.networkError'))
    // 根据服务器响应的错误状态码，做不同的处理
    if (response) checkStatus(response.status)
    // 服务器结果都没有返回(可能服务器错误可能客户端断网)，断网处理:可以跳转到断网页面
    if (!window.navigator.onLine && router.currentRoute.value.path !== '/500')
      router.replace({
        path: '/500',
        query: {
          redirect: router.currentRoute.value.fullPath
        }
      })
    return Promise.reject(error)
  }
);
```

+ 在获取到接口的响应后，不管成功或失败，先尝试关闭全局 loading`tryHideFullScreenLoading`，然后根据成功或失败做不同的处理。
+ 当业务上的code与定义的成功的编码` ResultEnum.SUCCESS`不相等时，可根据请求时设置的config的errMsg确定是否直接在此处显示后端返回的报错信息

:::info
默认都是直接显示报错信息，若需要不在此处处理错误信息显示可在接口请求时设置config.errMsg为false

:::



:::info
这里的请求成功指的是**网络请求**，不是**业务逻辑**成功。

:::

+ 请求成功后会判断接口返回的响应数据里的 code。根据不同的 code 做不同的处理。  
这里要注意`ResultEnum`中定义的 code 是不是跟你业务上的 code 一样。
+ 请求失败也是一样，只不过这里的失败是指网络失败。网络请求失败后服务器返回的状态码都是有迹可循的，只需要根据不同的状态码，做不同的处理。这就是`checkStatus`的工作。

### 示例（重点）
> 现在要写一个登录接口
>

1. api->modules 中新建一个`login.ts`文件。
2. 在`login.ts`中引入封装后的 axios。
3. 在`login.ts`中引入相应的后端服务前缀
4. 编写请求函数。
5. 可选的，给请求函数的入参和返回值加上 TS 类型限制。

```typescript
import { PORT_SYSTEM } from '@/api/config/service-port'
import http from '@/api'

/**
 * @name 登录模块
 */
// 登录模块
export namespace Login {
  export interface ReqLoginForm {
    userName: string
    password: string
  }
  export interface ResLogin {
    token: string
    userInfo: {
      staffId: number
      [key: string]: any
    }
  }
}
// 用户登录
// 松散的类型限制
export const loginApi = (params: any) => {
    return http.post(PORT_SYSTEM + `/user/auth/login`, params,{ loading: false });
};

// 严格的类型限制
export const typeloginApi = (params: Login.ReqLoginForm) => {
  return http.post<Login.ResLogin>(PORT_SYSTEM + `/user/auth/login`, params, { loading: false })
}



```

如何使用 api 函数呢，很简单。

```typescript
import { loginApi } from "@/api/modules/login";

// 模拟表单数据
const form = {
    account: "admin",
    password: "123456",
};
const login = async () => {
    // 如果请求成功，那么就会执行下面的代码。基本上不需要错误处理，错误情况都被拦截了
    // 除非你有需要，你可以使用`.catch`
    // const data = await loginApi(form).catch((err)=>{
    // 错误处理
    // })
    const data = await loginApi(form);
    // 保存token，跳转页面等操作
};
```

